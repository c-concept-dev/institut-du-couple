<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clone de Personnalit√© v8.0 ULTIMATE - Institut du Couple</title>
    
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- p5.js for Avatar Animation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    
    <!-- jsPDF for Psychological Report -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    
    <style>
        /* ============================================
           CSS VARIABLES - INSTITUT DU COUPLE
        ============================================ */
        :root {
            /* Institut du Couple Palette */
            --primary: #8FAFB1;           /* Mer - Bleu-Vert Doux */
            --primary-dark: #7A9A9C;      /* Mer fonc√© */
            --secondary: #C8D0C3;         /* Vert Sauge Clair */
            --accent-warm: #D8CDBB;       /* Beige Sable */
            --accent-neutral: #E6D7C3;    /* Sable */
            --white: #FFFFFF;             /* Blanc Pur */
            
            /* Semantic Colors */
            --danger: #ef4444;
            --warning: #f59e0b;
            --success: #C8D0C3;           /* Vert Sauge pour succ√®s */
            --info: #8FAFB1;              /* Mer pour info */
            
            /* Backgrounds */
            --bg-light: #FFFFFF;          /* Fond blanc pur */
            --bg-accent: #E6D7C3;         /* Fond sable */
            --bg-dark: #0f172a;
            
            /* Text */
            --text-light: #333333;
            --text-dark: #e2e8f0;
            --text-muted: #666666;
            
            /* Borders */
            --border-light: #D8CDBB;      /* Beige Sable */
            --border-dark: #334155;
            
            /* Depth Gauge Colors */
            --gauge-low: #ef4444;
            --gauge-medium: #f59e0b;
            --gauge-high: #C8D0C3;        /* Vert Sauge */
            
            /* Animation */
            --transition: 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* ============================================
           RESET & BASE
        ============================================ */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Montserrat', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-light);
            color: var(--text-light);
            line-height: 1.6;
            transition: background var(--transition), color var(--transition);
        }

        body.dark {
            background: var(--bg-dark);
            color: var(--text-dark);
        }

        /* ============================================
           LAYOUT
        ============================================ */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 70px;
            background: white;
            border-bottom: 1px solid var(--border-light);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 2rem;
            z-index: 100;
            transition: background var(--transition), border-color var(--transition);
        }

        body.dark .header {
            background: #1e293b;
            border-color: var(--border-dark);
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-size: 1.25rem;
            font-weight: 600;
        }

        .badge-premium {
            background: linear-gradient(135deg, #8FAFB1 0%, #C8D0C3 100%);
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 8px rgba(143, 175, 177, 0.3);
        }

        .header-controls {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .timer {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.875rem;
            color: #64748b;
        }

        .control-btn {
            background: none;
            border: none;
            font-size: 1.25rem;
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 8px;
            transition: background var(--transition);
        }

        .control-btn:hover {
            background: rgba(0, 0, 0, 0.05);
        }

        body.dark .control-btn:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .main-container {
            margin-top: 70px;
            height: calc(100vh - 70px);
            display: flex;
            position: relative;
        }

        /* ============================================
           WELCOME SCREEN
        ============================================ */
        .welcome-screen {
            position: fixed;
            top: 70px;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, #8FAFB1 0%, #C8D0C3 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 1;
            transition: opacity 0.5s ease;
        }

        .welcome-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .welcome-content {
            text-align: center;
            color: white;
            max-width: 600px;
            padding: 2rem;
        }

        .welcome-content h1 {
            font-size: 3rem;
            font-weight: 700;
            margin-bottom: 1rem;
        }

        .welcome-content p {
            font-size: 1.25rem;
            margin-bottom: 2rem;
            opacity: 0.9;
        }

        .start-btn {
            background: white;
            color: #8FAFB1;
            border: none;
            padding: 1rem 3rem;
            font-size: 1.125rem;
            font-weight: 600;
            border-radius: 50px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 10px 30px rgba(143, 175, 177, 0.3);
        }

        .start-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.3);
        }

        /* ============================================
           WARMUP MODAL
        ============================================ */
        .warmup-modal {
            position: fixed;
            top: 70px;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 999;
        }

        .warmup-modal.active {
            display: flex;
        }

        .warmup-content {
            background: white;
            border-radius: 20px;
            padding: 3rem;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        body.dark .warmup-content {
            background: #1e293b;
        }

        .warmup-progress {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 2rem;
        }

        .warmup-dot {
            flex: 1;
            height: 4px;
            background: #e2e8f0;
            border-radius: 2px;
            transition: background 0.3s;
        }

        .warmup-dot.active {
            background: var(--primary);
        }

        .warmup-question {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 2rem;
            text-align: center;
        }

        .warmup-options {
            display: grid;
            gap: 1rem;
        }

        .warmup-option {
            background: var(--bg-light);
            border: 2px solid var(--border-light);
            padding: 1.5rem;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
            font-size: 1.125rem;
        }

        body.dark .warmup-option {
            background: #0f172a;
            border-color: var(--border-dark);
        }

        .warmup-option:hover {
            border-color: var(--primary);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(37, 99, 235, 0.15);
        }

        .warmup-result {
            text-align: center;
            padding: 2rem 0;
        }

        .warmup-result h2 {
            font-size: 2rem;
            margin-bottom: 1rem;
            color: var(--primary);
        }

        .warmup-result p {
            font-size: 1.125rem;
            color: #64748b;
            margin-bottom: 2rem;
        }

        /* ============================================
           CHAT INTERFACE
        ============================================ */
        .chat-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            max-width: 800px;
            margin: 0 auto;
            padding: 2rem;
            width: 100%;
        }

        .messages {
            flex: 1;
            overflow-y: auto;
            padding: 1rem 0;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .message {
            display: flex;
            gap: 1rem;
            animation: fadeInUp 0.3s ease;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .message.assistant {
            align-self: flex-start;
        }

        .message.user {
            align-self: flex-end;
            flex-direction: row-reverse;
        }

        .message-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, #8FAFB1 0%, #C8D0C3 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            flex-shrink: 0;
        }

        .message.user .message-avatar {
            background: var(--secondary);
        }

        .message-content {
            background: white;
            padding: 1rem 1.25rem;
            border-radius: 18px;
            max-width: 70%;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }

        body.dark .message-content {
            background: #1e293b;
        }

        .message.user .message-content {
            background: var(--primary);
            color: white;
        }

        .typing-indicator {
            display: none;
            align-items: center;
            gap: 0.5rem;
            padding: 1rem;
        }

        .typing-indicator.active {
            display: flex;
        }

        .typing-dot {
            width: 8px;
            height: 8px;
            background: #94a3b8;
            border-radius: 50%;
            animation: typing 1.4s infinite;
        }

        .typing-dot:nth-child(2) { animation-delay: 0.2s; }
        .typing-dot:nth-child(3) { animation-delay: 0.4s; }

        @keyframes typing {
            0%, 60%, 100% { transform: translateY(0); }
            30% { transform: translateY(-10px); }
        }

        /* ============================================
           INPUT AREA
        ============================================ */
        .input-container {
            padding: 1.5rem 0;
            border-top: 1px solid var(--border-light);
        }

        body.dark .input-container {
            border-color: var(--border-dark);
        }

        .input-wrapper {
            display: flex;
            gap: 1rem;
            align-items: flex-end;
        }

        .input-area {
            flex: 1;
            resize: none;
            border: 2px solid var(--border-light);
            border-radius: 12px;
            padding: 1rem;
            font-family: inherit;
            font-size: 1rem;
            min-height: 60px;
            max-height: 200px;
            transition: border-color 0.2s;
        }

        body.dark .input-area {
            background: #1e293b;
            border-color: var(--border-dark);
            color: var(--text-dark);
        }

        .input-area:focus {
            outline: none;
            border-color: var(--primary);
        }

        .send-btn, .voice-btn {
            width: 50px;
            height: 50px;
            border: none;
            border-radius: 12px;
            background: var(--primary);
            color: white;
            font-size: 1.25rem;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .send-btn:hover, .voice-btn:hover {
            background: var(--primary-dark);
            transform: translateY(-2px);
        }

        .send-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .voice-btn.recording {
            background: var(--danger);
            animation: pulse-record 1s infinite;
            box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7);
        }

        @keyframes pulse-record {
            0% { 
                transform: scale(1); 
                box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7);
            }
            50% { 
                transform: scale(1.05); 
                box-shadow: 0 0 0 10px rgba(239, 68, 68, 0);
            }
            100% { 
                transform: scale(1); 
                box-shadow: 0 0 0 0 rgba(239, 68, 68, 0);
            }
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        /* ============================================
           REVELATIONS PANEL
        ============================================ */
        .revelations-panel {
            position: fixed;
            right: -400px;
            top: 70px;
            width: 380px;
            height: calc(100vh - 70px);
            background: white;
            border-left: 1px solid var(--border-light);
            transition: right 0.3s ease;
            z-index: 50;
            display: flex;
            flex-direction: column;
            box-shadow: -4px 0 12px rgba(0, 0, 0, 0.1);
        }

        body.dark .revelations-panel {
            background: #1e293b;
            border-color: var(--border-dark);
        }

        .revelations-panel.open {
            right: 0;
        }

        .revelations-header {
            padding: 1.5rem;
            border-bottom: 1px solid var(--border-light);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        body.dark .revelations-header {
            border-color: var(--border-dark);
        }

        .revelations-header h3 {
            font-size: 1.25rem;
            font-weight: 600;
        }

        .revelations-content {
            flex: 1;
            overflow-y: auto;
            padding: 1.5rem;
        }

        .revelation-progress {
            background: var(--bg-light);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
        }

        body.dark .revelation-progress {
            background: #0f172a;
        }

        .progress-bar-container {
            background: #e2e8f0;
            height: 8px;
            border-radius: 4px;
            overflow: hidden;
            margin: 1rem 0;
        }

        .progress-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            transition: width 0.5s ease;
            width: 0%;
        }

        .progress-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.875rem;
            color: #64748b;
        }

        .badges-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .badge-item {
            background: var(--bg-light);
            border-radius: 12px;
            padding: 1rem;
            text-align: center;
            position: relative;
            transition: all 0.3s;
        }

        body.dark .badge-item {
            background: #0f172a;
        }

        .badge-item.unlocked {
            background: linear-gradient(135deg, #8FAFB1 0%, #C8D0C3 100%);
            color: white;
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(143, 175, 177, 0.3);
        }

        .badge-icon {
            font-size: 2rem;
            margin-bottom: 0.5rem;
        }

        .badge-item.locked .badge-icon {
            opacity: 0.3;
        }

        .badge-title {
            font-size: 0.875rem;
            font-weight: 600;
        }

        .badge-milestone {
            font-size: 0.75rem;
            opacity: 0.8;
        }

        .insights-section {
            background: var(--bg-light);
            border-radius: 12px;
            padding: 1.5rem;
        }

        body.dark .insights-section {
            background: #0f172a;
        }

        .insights-section h4 {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 1rem;
        }

        .insight-item {
            padding: 1rem;
            background: white;
            border-radius: 8px;
            margin-bottom: 0.75rem;
            font-size: 0.875rem;
            line-height: 1.5;
            border-left: 3px solid var(--primary);
        }

        body.dark .insight-item {
            background: #1e293b;
        }

        /* Paraverbal Section */
        .paraverbal-section {
            background: var(--bg-light);
            border-radius: 12px;
            padding: 1.5rem;
            margin-top: 1rem;
        }

        body.dark .paraverbal-section {
            background: #0f172a;
        }

        .paraverbal-section h4 {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--primary);
        }

        .paraverbal-metrics {
            display: grid;
            gap: 0.75rem;
        }

        .metric-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1rem;
            background: white;
            border-radius: 8px;
            font-size: 0.875rem;
        }

        body.dark .metric-item {
            background: #1e293b;
        }

        .metric-label {
            font-weight: 500;
            color: #64748b;
        }

        .metric-value {
            font-weight: 600;
            color: var(--primary);
        }

        /* Concordance Dashboard Styles */
        .concordance-section {
            background: var(--bg-light);
            border-radius: 12px;
            padding: 1.5rem;
            margin-top: 1rem;
        }

        body.dark .concordance-section {
            background: #0f172a;
        }

        .concordance-section h4 {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--primary);
        }

        .concordance-header {
            margin-bottom: 1.5rem;
        }

        .concordance-score-display {
            display: flex;
            align-items: baseline;
            gap: 0.75rem;
            margin-bottom: 0.5rem;
        }

        .concordance-score {
            font-size: 2rem;
            font-weight: 700;
            color: var(--primary);
        }

        .concordance-status {
            font-size: 0.875rem;
            font-weight: 500;
            color: #64748b;
        }

        .concordance-progress-bar {
            height: 8px;
            background: #e2e8f0;
            border-radius: 4px;
            overflow: hidden;
        }

        body.dark .concordance-progress-bar {
            background: #1e293b;
        }

        .concordance-bar {
            height: 100%;
            background: var(--primary);
            border-radius: 4px;
            transition: width 0.5s ease, background-color 0.3s ease;
        }

        .concordance-dimensions {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            margin-bottom: 1rem;
        }

        .concordance-dimension {
            display: grid;
            grid-template-columns: 120px 1fr 60px;
            align-items: center;
            gap: 0.75rem;
            font-size: 0.875rem;
        }

        .dimension-label {
            font-weight: 500;
            color: #64748b;
        }

        .dimension-bar-container {
            height: 6px;
            background: #e2e8f0;
            border-radius: 3px;
            overflow: hidden;
        }

        body.dark .dimension-bar-container {
            background: #1e293b;
        }

        .dimension-bar {
            height: 100%;
            border-radius: 3px;
            transition: width 0.5s ease, background-color 0.3s ease;
        }

        .dimension-value {
            text-align: right;
            font-weight: 600;
            color: var(--text);
        }

        .concordance-actions {
            display: flex;
            gap: 0.75rem;
            margin-top: 1rem;
        }

        .concordance-btn {
            flex: 1;
            padding: 0.75rem 1rem;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 0.875rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .concordance-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(143, 175, 177, 0.3);
        }

        .concordance-btn.secondary {
            background: transparent;
            color: var(--primary);
            border: 1.5px solid var(--primary);
        }

        .concordance-btn.secondary:hover {
            background: var(--bg-light);
        }

        body.dark .concordance-btn.secondary:hover {
            background: #1e293b;
        }

        /* Feedback Request Styles */
        .feedback-request {
            border-left: 3px solid var(--accent);
            background: linear-gradient(135deg, var(--bg-light) 0%, white 100%);
        }

        body.dark .feedback-request {
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
        }

        .feedback-buttons {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .feedback-btn {
            flex: 1;
            padding: 0.5rem 1rem;
            border: 1.5px solid #e2e8f0;
            background: white;
            border-radius: 8px;
            font-size: 0.875rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        body.dark .feedback-btn {
            background: #1e293b;
            border-color: #334155;
        }

        .feedback-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .feedback-btn.positive {
            border-color: #10b981;
            color: #10b981;
        }

        .feedback-btn.positive:hover {
            background: #10b981;
            color: white;
        }

        .feedback-btn.neutral {
            border-color: #f59e0b;
            color: #f59e0b;
        }

        .feedback-btn.neutral:hover {
            background: #f59e0b;
            color: white;
        }

        .feedback-btn.negative {
            border-color: #ef4444;
            color: #ef4444;
        }

        .feedback-btn.negative:hover {
            background: #ef4444;
            color: white;
        }

        .feedback-details-options {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .detail-option {
            padding: 0.5rem 0.75rem;
            background: white;
            border: 1.5px solid var(--primary);
            color: var(--primary);
            border-radius: 6px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        body.dark .detail-option {
            background: #1e293b;
        }

        .detail-option:hover {
            background: var(--primary);
            color: white;
        }

        /* ============================================ */
        /* MODULE 13: Intelligence & M√©moire Styles */
        /* ============================================ */
        
        .intelligence-section {
            background: var(--bg-light);
            border-radius: 12px;
            padding: 1.5rem;
            margin-top: 1rem;
        }

        body.dark .intelligence-section {
            background: #0f172a;
        }

        .intelligence-section h4 {
            font-size: 1rem;
            font-weight: 600;
            color: var(--text);
            margin-bottom: 1rem;
        }

        .memory-summary {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .memory-stat {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0.75rem;
            background: white;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
        }

        body.dark .memory-stat {
            background: #1e293b;
            border-color: #334155;
        }

        .memory-label {
            font-size: 0.7rem;
            color: var(--text-light);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.25rem;
        }

        .memory-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--primary);
        }

        .memory-unit {
            font-size: 0.7rem;
            color: var(--text-light);
        }

        .tics-summary h5 {
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
            color: var(--text);
        }

        .tics-list {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            min-height: 2rem;
        }

        .tic-badge {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.35rem 0.75rem;
            background: linear-gradient(135deg, var(--primary), var(--accent));
            color: white;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 500;
        }

        .tic-badge .tic-freq {
            font-size: 0.65rem;
            opacity: 0.8;
        }

        .tics-status {
            font-size: 0.8rem;
            color: var(--text-light);
            margin-top: 0.5rem;
            font-style: italic;
        }

        .revelations-toggle {
            position: fixed;
            right: 1rem;
            bottom: 2rem;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(135deg, #8FAFB1 0%, #C8D0C3 100%);
            color: white;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(143, 175, 177, 0.3);
            z-index: 60;
            transition: transform 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .revelations-toggle:hover {
            transform: translateY(-2px) scale(1.05);
        }

        .badge-count {
            position: absolute;
            top: -5px;
            right: -5px;
            background: var(--danger);
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            font-weight: 600;
        }

        /* ============================================
           DEPTH GAUGE
        ============================================ */
        .depth-gauge {
            position: fixed;
            left: 2rem;
            top: 50%;
            transform: translateY(-50%);
            width: 60px;
            z-index: 40;
        }

        .gauge-container {
            background: white;
            border-radius: 30px;
            padding: 1rem 0.5rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        body.dark .gauge-container {
            background: #1e293b;
        }

        .gauge-bar {
            width: 20px;
            height: 200px;
            background: #e2e8f0;
            border-radius: 10px;
            position: relative;
            overflow: hidden;
            margin: 0 auto 1rem;
        }

        .gauge-fill {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 0%;
            background: linear-gradient(to top, var(--gauge-low), var(--gauge-medium), var(--gauge-high));
            transition: height 0.5s ease, background 0.3s ease;
            border-radius: 10px;
        }

        .gauge-percentage {
            text-align: center;
            font-size: 1rem;
            font-weight: 600;
            color: var(--primary);
        }

        .gauge-label {
            text-align: center;
            font-size: 0.75rem;
            color: #64748b;
            margin-top: 0.5rem;
        }

        /* ============================================
           REFLECTION PAUSE MODAL
        ============================================ */
        .reflection-modal {
            position: fixed;
            top: 70px;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 998;
        }

        .reflection-modal.active {
            display: flex;
        }

        .reflection-content {
            background: white;
            border-radius: 20px;
            padding: 3rem;
            max-width: 600px;
            width: 90%;
            text-align: center;
        }

        body.dark .reflection-content {
            background: #1e293b;
        }

        .reflection-content h2 {
            font-size: 2rem;
            margin-bottom: 1rem;
        }

        .reflection-question {
            font-size: 1.25rem;
            color: #64748b;
            margin: 2rem 0;
            font-style: italic;
        }

        .breathing-circle {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: linear-gradient(135deg, #8FAFB1 0%, #C8D0C3 100%);
            margin: 2rem auto;
            animation: breathe 4s infinite;
        }

        @keyframes breathe {
            0%, 100% { transform: scale(1); opacity: 0.7; }
            50% { transform: scale(1.2); opacity: 1; }
        }

        .reflection-timer {
            font-size: 3rem;
            font-weight: 700;
            color: var(--primary);
            margin: 2rem 0;
        }

        .reflection-notes {
            width: 100%;
            min-height: 100px;
            padding: 1rem;
            border: 2px solid var(--border-light);
            border-radius: 12px;
            font-family: inherit;
            font-size: 1rem;
            margin: 1rem 0;
        }

        body.dark .reflection-notes {
            background: #0f172a;
            border-color: var(--border-dark);
            color: var(--text-dark);
        }

        .reflection-buttons {
            display: flex;
            gap: 1rem;
            margin-top: 1.5rem;
        }

        .reflection-buttons button {
            flex: 1;
            padding: 1rem;
            border: none;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-secondary {
            background: var(--bg-light);
            color: var(--text-light);
        }

        body.dark .btn-secondary {
            background: #0f172a;
            color: var(--text-dark);
        }

        .btn-primary {
            background: var(--primary);
            color: white;
        }

        .btn-primary:hover, .btn-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        /* ============================================
           STATS PANEL
        ============================================ */
        .stats-panel {
            position: fixed;
            top: 70px;
            right: 1rem;
            background: white;
            border-radius: 12px;
            padding: 1rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            display: none;
            z-index: 45;
        }

        body.dark .stats-panel {
            background: #1e293b;
        }

        .stats-panel.active {
            display: block;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0;
            border-bottom: 1px solid var(--border-light);
        }

        body.dark .stat-item {
            border-color: var(--border-dark);
        }

        .stat-item:last-child {
            border-bottom: none;
        }

        .stat-label {
            font-size: 0.875rem;
            color: #64748b;
        }

        .stat-value {
            font-weight: 600;
            color: var(--primary);
        }

        /* ============================================
           TOAST NOTIFICATIONS
        ============================================ */
        .toast-container {
            position: fixed;
            top: 90px;
            right: 1rem;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .toast {
            background: white;
            border-radius: 12px;
            padding: 1rem 1.5rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            display: flex;
            align-items: center;
            gap: 1rem;
            min-width: 300px;
            animation: slideIn 0.3s ease;
        }

        body.dark .toast {
            background: #1e293b;
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .toast.success {
            border-left: 4px solid var(--success);
        }

        .toast.info {
            border-left: 4px solid var(--info);
        }

        .toast.warning {
            border-left: 4px solid var(--warning);
        }

        .toast.danger {
            border-left: 4px solid var(--danger);
        }

        .toast-icon {
            font-size: 1.5rem;
        }

        .toast-content {
            flex: 1;
        }

        .toast-title {
            font-weight: 600;
            margin-bottom: 0.25rem;
        }

        .toast-message {
            font-size: 0.875rem;
            color: #64748b;
        }

        /* ============================================
           LOADING OVERLAY
        ============================================ */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .loading-overlay.active {
            display: flex;
        }

        .loader {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* ============================================
           RESPONSIVE
        ============================================ */
        @media (max-width: 768px) {
            .header {
                padding: 0 1rem;
            }

            .logo {
                font-size: 1rem;
            }

            .timer {
                display: none;
            }

            .chat-container {
                padding: 1rem;
            }

            .message-content {
                max-width: 85%;
            }

            .revelations-panel {
                width: 100%;
                right: -100%;
            }

            .depth-gauge {
                left: 1rem;
                transform: translateY(-50%) scale(0.8);
            }

            .revelations-toggle {
                right: 1rem;
                bottom: 1rem;
                width: 50px;
                height: 50px;
            }
        }

        /* ============================================
           UTILITIES
        ============================================ */
        .hidden {
            display: none !important;
        }

        .fade-in {
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .slide-up {
            animation: slideUp 0.3s ease;
        }

        @keyframes slideUp {
            from {
                transform: translateY(20px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        /* ============================================
           AVATAR SIDEBAR
        ============================================ */
        .avatar-sidebar {
            position: fixed;
            left: 0;
            top: 70px;
            width: 320px;
            height: calc(100vh - 70px);
            background: var(--white);
            border-right: 1px solid var(--border-light);
            padding: 1.5rem;
            overflow-y: auto;
            z-index: 90;
            transition: transform 0.3s ease, background var(--transition), border-color var(--transition);
        }

        body.dark .avatar-sidebar {
            background: #1e293b;
            border-color: var(--border-dark);
        }

        .avatar-sidebar.hidden {
            transform: translateX(-100%);
        }

        .avatar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .avatar-header h3 {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--primary);
        }

        .avatar-toggle-btn {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.25rem;
            color: var(--text-muted);
            transition: color var(--transition);
        }

        .avatar-toggle-btn:hover {
            color: var(--primary);
        }

        .avatar-container {
            width: 100%;
            background: var(--bg-accent);
            border-radius: 12px;
            padding: 1rem;
            margin-bottom: 1.5rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
        }

        /* Avatar photo + overlay system */
        .avatar-display {
            position: relative;
            width: 280px;
            height: 280px;
        }

        .avatar-photo-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 280px;
            height: 280px;
            border-radius: 50%;
            background-size: cover;
            background-position: center;
            z-index: 1;
            display: none; /* Hidden by default, shown when photo uploaded */
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .avatar-photo-layer.active {
            display: block;
        }

        #avatar {
            position: absolute;
            top: 0;
            left: 0;
            width: 280px;
            height: 280px;
            z-index: 2; /* Overlay on top */
        }

        /* Upload button */
        /* Avatar name input - sobre */
        .avatar-name-input {
            padding: 0.5rem;
            border: 1px solid var(--primary);
            border-radius: 8px;
            font-size: 0.9rem;
            font-family: inherit;
            background: white;
            transition: all var(--transition);
        }

        .avatar-name-input:focus {
            outline: none;
            border-color: var(--primary-dark);
            box-shadow: 0 0 0 3px rgba(143, 175, 177, 0.1);
        }

        /* Avatar photo actions - liens simples */
        .avatar-photo-actions {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.85rem;
        }

        .avatar-link {
            color: #9ca3af;
            text-decoration: none;
            cursor: pointer;
            background: none;
            border: none;
            padding: 0;
            font-family: inherit;
            font-size: inherit;
            transition: color var(--transition);
        }

        .avatar-link:hover {
            color: var(--primary);
        }

        .avatar-link-separator {
            color: #d1d5db;
        }

        /* Avatar export button */
        .avatar-export-btn {
            padding: 0.5rem 1rem;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85rem;
            font-family: inherit;
            transition: all var(--transition);
            margin-top: 0.5rem;
        }

        .avatar-export-btn:hover {
            background: var(--primary-dark);
            transform: translateY(-1px);
        }

        /* Mode toggle */
        .avatar-mode-toggle {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }

        .mode-btn {
            padding: 0.4rem 0.8rem;
            background: var(--bg-light);
            border: 1px solid var(--border-light);
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all var(--transition);
        }

        body.dark .mode-btn {
            background: #0f172a;
            border-color: var(--border-dark);
        }

        .mode-btn.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        .mode-btn:hover:not(.active) {
            border-color: var(--primary);
        }

        .avatar-traits {
            background: var(--bg-light);
            border: 1px solid var(--border-light);
            border-radius: 12px;
            padding: 1rem;
        }

        body.dark .avatar-traits {
            background: #0f172a;
            border-color: var(--border-dark);
        }

        .avatar-traits h4 {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--primary);
            margin-bottom: 0.75rem;
        }

        .trait-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
            font-size: 0.85rem;
        }

        .trait-item:last-child {
            margin-bottom: 0;
        }

        .trait-label {
            color: var(--text-muted);
        }

        .trait-value {
            font-weight: 600;
            color: var(--primary);
        }

        .trait-bar-container {
            width: 100%;
            height: 6px;
            background: var(--bg-accent);
            border-radius: 3px;
            margin-top: 0.25rem;
            overflow: hidden;
        }

        .trait-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            border-radius: 3px;
            transition: width 0.5s ease;
        }

        /* Avatar Toggle Button (when sidebar is hidden) */
        .avatar-float-toggle {
            position: fixed;
            left: 1rem;
            bottom: 1rem;
            width: 60px;
            height: 60px;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 1.8rem;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(143, 175, 177, 0.3);
            z-index: 95;
            display: none;
            transition: all var(--transition);
        }

        .avatar-float-toggle:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 16px rgba(143, 175, 177, 0.4);
        }

        .avatar-float-toggle.visible {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Adjust main container when sidebar is visible */
        .main-container.with-avatar-sidebar {
            margin-left: 320px;
        }

        /* Responsive */
        @media (max-width: 1024px) {
            .avatar-sidebar {
                transform: translateX(-100%);
            }

            .avatar-sidebar.visible {
                transform: translateX(0);
            }

            .main-container.with-avatar-sidebar {
                margin-left: 0;
            }

            .avatar-float-toggle {
                display: flex;
            }
        }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="header">
        <div class="logo">
            Clone de Personnalit√©
            <span class="badge-premium">Premium</span>
        </div>
        <div class="header-controls">
            <div class="timer" id="timer">00:00</div>
            <button class="control-btn" id="statsToggle" title="Statistiques">Stats</button>
            <button class="control-btn" id="themeToggle" title="Changer le th√®me">üåì</button>
            <button class="control-btn" id="pauseBtn" title="Pause">‚è∏Ô∏è</button>
            <button class="control-btn" id="exportBtn" title="Exporter JSON">JSON</button>
            <button class="control-btn" id="pdfBtn" title="Rapport Psychologique PDF">PDF</button>
        </div>
    </div>

    <!-- Avatar Sidebar -->
    <div class="avatar-sidebar" id="avatarSidebar">
        <div class="avatar-header">
            <h3>Avatar Personnalit√©</h3>
            <button class="avatar-toggle-btn" id="avatarToggleBtn" title="Masquer">‚óÑ</button>
        </div>
        
        <!-- Mode Toggle -->
        <div class="avatar-mode-toggle">
            <button class="mode-btn" id="modeGenerative">G√©n√©ratif</button>
            <button class="mode-btn active" id="modeHybrid">Hybride</button>
        </div>
        
        <div class="avatar-container">
            <!-- Avatar Display (Photo + Overlay) -->
            <div class="avatar-display">
                <div class="avatar-photo-layer" id="avatarPhotoLayer"></div>
                <div id="avatar"></div>
            </div>
            
            <!-- Upload Controls -->
            <div style="display: flex; flex-direction: column; gap: 0.75rem; width: 100%;">
                <!-- Name input -->
                <input 
                    type="text" 
                    id="avatarNameInput" 
                    placeholder="Votre pr√©nom" 
                    class="avatar-name-input"
                />
                
                <!-- Photo actions (simple links) -->
                <div class="avatar-photo-actions">
                    <label for="avatarUploadInput" class="avatar-link">
                        modifier
                        <input type="file" id="avatarUploadInput" accept="image/*" style="display: none;">
                    </label>
                    <span class="avatar-link-separator">|</span>
                    <button id="avatarRemoveBtn" class="avatar-link" style="display: none;">
                        supprimer
                    </button>
                </div>
                
                <!-- Export button -->
                <button id="avatarExportBtn" class="avatar-export-btn" style="display: none;">
                    T√©l√©charger mon avatar
                </button>
            </div>
        </div>
        
        <div class="avatar-traits">
            <h4>Traits Big Five</h4>
            <div class="trait-item">
                <span class="trait-label">Ouverture</span>
                <span class="trait-value" id="traitOpenness">7.0</span>
            </div>
            <div class="trait-bar-container">
                <div class="trait-bar-fill" id="barOpenness" style="width: 70%"></div>
            </div>
            
            <div class="trait-item" style="margin-top: 0.75rem;">
                <span class="trait-label">Conscienciosit√©</span>
                <span class="trait-value" id="traitConscientiousness">6.0</span>
            </div>
            <div class="trait-bar-container">
                <div class="trait-bar-fill" id="barConscientiousness" style="width: 60%"></div>
            </div>
            
            <div class="trait-item" style="margin-top: 0.75rem;">
                <span class="trait-label">Extraversion</span>
                <span class="trait-value" id="traitExtraversion">6.0</span>
            </div>
            <div class="trait-bar-container">
                <div class="trait-bar-fill" id="barExtraversion" style="width: 60%"></div>
            </div>
            
            <div class="trait-item" style="margin-top: 0.75rem;">
                <span class="trait-label">Agr√©abilit√©</span>
                <span class="trait-value" id="traitAgreeableness">7.0</span>
            </div>
            <div class="trait-bar-container">
                <div class="trait-bar-fill" id="barAgreeableness" style="width: 70%"></div>
            </div>
            
            <div class="trait-item" style="margin-top: 0.75rem;">
                <span class="trait-label">Stabilit√© √âmotionnelle</span>
                <span class="trait-value" id="traitEmotionalStability">6.0</span>
            </div>
            <div class="trait-bar-container">
                <div class="trait-bar-fill" id="barEmotionalStability" style="width: 60%"></div>
            </div>
        </div>
    </div>

    <!-- Avatar Float Toggle (mobile) -->
    <button class="avatar-float-toggle" id="avatarFloatToggle">Avatar</button>

    <!-- Main Container -->
    <div class="main-container with-avatar-sidebar">
        <!-- Welcome Screen -->
        <div class="welcome-screen" id="welcomeScreen">
            <div class="welcome-content">
                <h1>Bienvenue</h1>
                <p>Cr√©ons ensemble votre clone de personnalit√© uploadable dans une IA. Cette interview dure environ 45-65 minutes et g√©n√®re un profil unique de 25-30k mots.</p>
                <button class="start-btn" id="startBtn">Commencer l'interview</button>
            </div>
        </div>

        <!-- Warm-up Modal -->
        <div class="warmup-modal" id="warmupModal">
            <div class="warmup-content">
                <div class="warmup-progress" id="warmupProgress"></div>
                <div id="warmupQuestionContainer"></div>
            </div>
        </div>

        <!-- Depth Gauge -->
        <div class="depth-gauge">
            <div class="gauge-container">
                <div class="gauge-bar">
                    <div class="gauge-fill" id="gaugeFill"></div>
                </div>
                <div class="gauge-percentage" id="gaugePercentage">0%</div>
                <div class="gauge-label">Profondeur</div>
            </div>
        </div>

        <!-- Chat Container -->
        <div class="chat-container" id="chatContainer" style="display: none;">
            <div class="messages" id="messages">
                <div class="typing-indicator" id="typingIndicator">
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                </div>
            </div>
            
            <div class="input-container" id="inputContainer">
                <div class="input-wrapper">
                    <textarea 
                        id="inputArea" 
                        class="input-area" 
                        placeholder="√âcrivez votre r√©ponse..."
                        rows="2"
                    ></textarea>
                    <button class="voice-btn" id="voiceBtn" title="Dict√©e vocale">üé§</button>
                    <button class="send-btn" id="sendBtn">‚û§</button>
                </div>
            </div>
        </div>

        <!-- Revelations Panel -->
        <div class="revelations-panel" id="revelationsPanel">
            <div class="revelations-header">
                <h3>R√©v√©lations</h3>
                <button class="control-btn" id="closeRevelations">‚úï</button>
            </div>
            <div class="revelations-content">
                <div class="revelation-progress">
                    <h4>Progression</h4>
                    <div class="progress-bar-container">
                        <div class="progress-bar-fill" id="revelationsProgress"></div>
                    </div>
                    <div class="progress-label">
                        <span id="currentResponses">0</span>
                        <span>40 r√©ponses</span>
                    </div>
                </div>

                <div class="badges-grid" id="badgesGrid">
                    <div class="badge-item locked" data-milestone="10">
                        <div class="badge-icon"></div>
                        <div class="badge-title">Explorer</div>
                        <div class="badge-milestone">10 r√©ponses</div>
                    </div>
                    <div class="badge-item locked" data-milestone="20">
                        <div class="badge-icon"></div>
                        <div class="badge-title">Introspectif</div>
                        <div class="badge-milestone">20 r√©ponses</div>
                    </div>
                    <div class="badge-item locked" data-milestone="30">
                        <div class="badge-icon"></div>
                        <div class="badge-title">Profond</div>
                        <div class="badge-milestone">30 r√©ponses</div>
                    </div>
                    <div class="badge-item locked" data-milestone="40">
                        <div class="badge-icon"></div>
                        <div class="badge-title">Ma√Ætre</div>
                        <div class="badge-milestone">40 r√©ponses</div>
                    </div>
                </div>

                <div class="insights-section">
                    <h4>Insights</h4>
                    <div id="insightsContainer"></div>
                </div>

                <div class="paraverbal-section">
                    <h4>Analyse Paraverbale</h4>
                    <div class="paraverbal-metrics">
                        <div class="metric-item">
                            <span class="metric-label">Rythme</span>
                            <span class="metric-value" id="paraverbalRythm">--</span>
                        </div>
                        <div class="metric-item">
                            <span class="metric-label">Expressivit√©</span>
                            <span class="metric-value" id="paraverbalExpressiveness">--</span>
                        </div>
                        <div class="metric-item">
                            <span class="metric-label">Profondeur</span>
                            <span class="metric-value" id="paraverbalDepth">--</span>
                        </div>
                        <div class="metric-item">
                            <span class="metric-label">Style</span>
                            <span class="metric-value" id="paraverbalStyle">--</span>
                        </div>
                    </div>
                </div>

                <!-- Concordance Dashboard -->
                <div class="concordance-section" id="concordanceSection" style="display: none;">
                    <h4>Concordance Clone</h4>
                    <div class="concordance-header">
                        <div class="concordance-score-display">
                            <span class="concordance-score" id="concordanceScore">--</span>
                            <span class="concordance-status" id="concordanceStatus">--</span>
                        </div>
                        <div class="concordance-progress-bar">
                            <div class="concordance-bar" id="concordanceBar"></div>
                        </div>
                    </div>
                    
                    <div class="concordance-dimensions" id="concordanceDimensions">
                        <!-- Dimensions seront remplies dynamiquement -->
                    </div>
                    
                    <div class="concordance-actions">
                        <button class="concordance-btn" id="improveConcordanceBtn" style="display: none;">
                            Am√©liorer vers 85%
                        </button>
                        <button class="concordance-btn secondary" id="diagnoseConcordanceBtn">
                            Diagnostic d√©taill√©
                        </button>
                    </div>
                </div>

                <!-- MODULE 13: Intelligence & M√©moire -->
                <div class="intelligence-section" id="intelligenceSection" style="display: none;">
                    <h4>Intelligence & M√©moire</h4>
                    
                    <div class="memory-summary">
                        <div class="memory-stat">
                            <span class="memory-label">Conversation</span>
                            <span class="memory-value" id="memoryMessagesCount">0</span>
                            <span class="memory-unit">messages</span>
                        </div>
                        <div class="memory-stat">
                            <span class="memory-label">Topics explor√©s</span>
                            <span class="memory-value" id="memoryTopicsCount">0</span>
                        </div>
                        <div class="memory-stat">
                            <span class="memory-label">Humeur actuelle</span>
                            <span class="memory-value" id="memoryMood">neutral</span>
                        </div>
                    </div>
                    
                    <div class="tics-summary" style="margin-top: 1rem;">
                        <h5 style="font-size: 0.9rem; margin-bottom: 0.5rem; color: var(--text);">Tics de langage appris</h5>
                        <div class="tics-list" id="ticsList">
                            <!-- Rempli dynamiquement -->
                        </div>
                        <div class="tics-status" id="ticsStatus" style="font-size: 0.8rem; color: var(--text-light); margin-top: 0.5rem;">
                            Apprentissage en cours...
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Revelations Toggle Button -->
        <button class="revelations-toggle" id="revelationsToggle">
            Insights
            <span class="badge-count" id="badgeCount">0</span>
        </button>

        <!-- Reflection Pause Modal -->
        <div class="reflection-modal" id="reflectionModal">
            <div class="reflection-content">
                <h2>üßò Moment de R√©flexion</h2>
                <div class="breathing-circle"></div>
                <p class="reflection-question" id="reflectionQuestion"></p>
                <div class="reflection-timer" id="reflectionTimer">2:00</div>
                <textarea 
                    class="reflection-notes" 
                    id="reflectionNotes"
                    placeholder="Notes personnelles (optionnel)..."
                ></textarea>
                <div class="reflection-buttons">
                    <button class="btn-secondary" id="skipReflection">Passer</button>
                    <button class="btn-primary" id="continueReflection">Continuer</button>
                </div>
            </div>
        </div>

        <!-- Stats Panel -->
        <div class="stats-panel" id="statsPanel">
            <div class="stat-item">
                <span class="stat-label">Temps</span>
                <span class="stat-value" id="statTime">00:00</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Questions</span>
                <span class="stat-value" id="statQuestions">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">R√©ponses</span>
                <span class="stat-value" id="statResponses">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Mots</span>
                <span class="stat-value" id="statWords">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Phase</span>
                <span class="stat-value" id="statPhase">0/6</span>
            </div>
        </div>

        <!-- Toast Container -->
        <div class="toast-container" id="toastContainer"></div>

        <!-- Loading Overlay -->
        <div class="loading-overlay" id="loadingOverlay">
            <div class="loader"></div>
        </div>
    </div>

    <script>
        // ============================================
        // CONFIGURATION
        // ============================================
        const CONFIG = {
            // ‚ö†Ô∏è √Ä CONFIGURER : Remplacez par votre URL Worker Cloudflare
            WORKER_URL: 'YOUR_CLOUDFLARE_WORKER_URL_HERE',
            MODEL: 'claude-sonnet-4-20250514',
            MAX_TOKENS: 4000,
            AUTOSAVE_INTERVAL: 30000, // 30 secondes
            ENCRYPTION_KEY_STORAGE: 'clone_encryption_key',
        };

        // ============================================
        // STATE MANAGEMENT
        // ============================================
        const state = {
            messages: [],
            startTime: null,
            elapsedSeconds: 0,
            timerInterval: null,
            currentPhase: 0,
            totalPhases: 6,
            questionCount: 0,
            responseCount: 0,
            totalWords: 0,
            isPaused: false,
            recognition: null,
            warmupCompleted: false,
            warmupResults: {},
            revelationsUnlocked: 0,
            contradictions: [],
            microExpressions: {},
            contexts: {},
            reflectionNotes: [],
            initialTraits: null,
            finalTraits: null,
        };

        // ============================================
        // DOM ELEMENTS
        // ============================================
        const elements = {
            welcomeScreen: document.getElementById('welcomeScreen'),
            warmupModal: document.getElementById('warmupModal'),
            chatContainer: document.getElementById('chatContainer'),
            inputContainer: document.getElementById('inputContainer'),
            messages: document.getElementById('messages'),
            inputArea: document.getElementById('inputArea'),
            sendBtn: document.getElementById('sendBtn'),
            voiceBtn: document.getElementById('voiceBtn'),
            timer: document.getElementById('timer'),
            typingIndicator: document.getElementById('typingIndicator'),
            themeToggle: document.getElementById('themeToggle'),
            statsToggle: document.getElementById('statsToggle'),
            statsPanel: document.getElementById('statsPanel'),
            pauseBtn: document.getElementById('pauseBtn'),
            exportBtn: document.getElementById('exportBtn'),
            pdfBtn: document.getElementById('pdfBtn'),
            loadingOverlay: document.getElementById('loadingOverlay'),
            startBtn: document.getElementById('startBtn'),
            revelationsPanel: document.getElementById('revelationsPanel'),
            revelationsToggle: document.getElementById('revelationsToggle'),
            closeRevelations: document.getElementById('closeRevelations'),
            badgeCount: document.getElementById('badgeCount'),
            revelationsProgress: document.getElementById('revelationsProgress'),
            currentResponses: document.getElementById('currentResponses'),
            badgesGrid: document.getElementById('badgesGrid'),
            insightsContainer: document.getElementById('insightsContainer'),
            gaugeFill: document.getElementById('gaugeFill'),
            gaugePercentage: document.getElementById('gaugePercentage'),
            reflectionModal: document.getElementById('reflectionModal'),
            reflectionQuestion: document.getElementById('reflectionQuestion'),
            reflectionTimer: document.getElementById('reflectionTimer'),
            reflectionNotes: document.getElementById('reflectionNotes'),
            skipReflection: document.getElementById('skipReflection'),
            continueReflection: document.getElementById('continueReflection'),
            toastContainer: document.getElementById('toastContainer'),
        };

        // Stats elements
        const statsElements = {
            time: document.getElementById('statTime'),
            questions: document.getElementById('statQuestions'),
            responses: document.getElementById('statResponses'),
            words: document.getElementById('statWords'),
            phase: document.getElementById('statPhase'),
        };

        // ============================================
        // UTILITY FUNCTIONS
        // ============================================
        const Utils = {
            showToast(message, type = 'info', subtitle = '') {
                const icons = {
                    success: '',
                    info: '',
                    warning: '',
                    danger: ''
                };

                const toast = document.createElement('div');
                toast.className = `toast ${type}`;
                toast.innerHTML = `
                    <span class="toast-icon">${icons[type]}</span>
                    <div class="toast-content">
                        <div class="toast-title">${message}</div>
                        ${subtitle ? `<div class="toast-message">${subtitle}</div>` : ''}
                    </div>
                `;

                elements.toastContainer.appendChild(toast);

                setTimeout(() => {
                    toast.style.animation = 'slideOut 0.3s ease forwards';
                    setTimeout(() => toast.remove(), 300);
                }, 4000);
            },

            formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
            },

            updateStats() {
                statsElements.time.textContent = Utils.formatTime(state.elapsedSeconds);
                statsElements.questions.textContent = state.questionCount;
                statsElements.responses.textContent = state.responseCount;
                statsElements.words.textContent = state.totalWords;
                statsElements.phase.textContent = `${state.currentPhase}/${state.totalPhases}`;
            },

            countWords(text) {
                return text.trim().split(/\s+/).length;
            }
        };

        // ============================================
        // MODULE 1: SIMPLE STORAGE (localStorage)
        // ============================================
        const SecureStorage = {
            save(key, data) {
                try {
                    localStorage.setItem(key, JSON.stringify(data));
                    return true;
                } catch (error) {
                    console.error('Storage error:', error);
                    return false;
                }
            },

            load(key) {
                try {
                    const data = localStorage.getItem(key);
                    return data ? JSON.parse(data) : null;
                } catch (error) {
                    console.error('Load error:', error);
                    return null;
                }
            },

            showToast(message, type) {
                Utils.showToast(message, type);
            }
        };

        // ============================================
        // MODULE 2: WARMUP QUIZ BUZZFEED
        // ============================================
        const Warmup = {
            questions: [
                {
                    q: "ü¶∏ Si tu √©tais un super-h√©ros, lequel serais-tu ?",
                    options: [
                        { text: "Superman - Force et justice", traits: { extraversion: 1, conscientiousness: 1 } },
                        { text: "Batman - Intelligence et strat√©gie", traits: { openness: 1, conscientiousness: 1 } },
                        { text: "Wonder Woman - Courage et compassion", traits: { agreeableness: 1, emotionalStability: 1 } },
                        { text: "Spider-Man - Responsabilit√© et humour", traits: { agreeableness: 1, openness: 1 } }
                    ]
                },
                {
                    q: "üåÖ Ton weekend id√©al ?",
                    options: [
                        { text: "Aventure en plein air", traits: { extraversion: 1, openness: 1 } },
                        { text: "Soir√©e entre amis", traits: { extraversion: 1, agreeableness: 1 } },
                        { text: "Lecture et d√©tente", traits: { openness: 1, conscientiousness: 1 } },
                        { text: "Projet cr√©atif", traits: { openness: 1, conscientiousness: 1 } }
                    ]
                },
                {
                    q: "Quel superpouvoir choisirais-tu ?",
                    options: [
                        { text: "Lire les pens√©es", traits: { openness: 1, agreeableness: 1 } },
                        { text: "Voyager dans le temps", traits: { openness: 1, conscientiousness: 1 } },
                        { text: "Voler", traits: { extraversion: 1, openness: 1 } },
                        { text: "Invisibilit√©", traits: { emotionalStability: 1, openness: 1 } }
                    ]
                },
                {
                    q: "üêæ Ton animal totem ?",
                    options: [
                        { text: "Lion - Leadership", traits: { extraversion: 1, conscientiousness: 1 } },
                        { text: "Dauphin - Sociabilit√©", traits: { extraversion: 1, agreeableness: 1 } },
                        { text: "Hibou - Sagesse", traits: { openness: 1, conscientiousness: 1 } },
                        { text: "Chat - Ind√©pendance", traits: { emotionalStability: 1, openness: 1 } }
                    ]
                },
                {
                    q: "üåà Ta couleur pr√©f√©r√©e ?",
                    options: [
                        { text: "Rouge - Passion", traits: { extraversion: 1, emotionalStability: 1 } },
                        { text: "Bleu - S√©r√©nit√©", traits: { emotionalStability: 1, agreeableness: 1 } },
                        { text: "Vert - Harmonie", traits: { agreeableness: 1, conscientiousness: 1 } },
                        { text: "Violet - Cr√©ativit√©", traits: { openness: 1, extraversion: 1 } }
                    ]
                },
                {
                    q: "üåç Destination de r√™ve ?",
                    options: [
                        { text: "Tokyo - Technologie", traits: { openness: 1, conscientiousness: 1 } },
                        { text: "Bali - Nature", traits: { emotionalStability: 1, openness: 1 } },
                        { text: "New York - Action", traits: { extraversion: 1, conscientiousness: 1 } },
                        { text: "Islande - Solitude", traits: { emotionalStability: 1, openness: 1 } }
                    ]
                },
                {
                    q: "üé¨ Genre de film favori ?",
                    options: [
                        { text: "Action/Aventure", traits: { extraversion: 1, openness: 1 } },
                        { text: "Com√©die", traits: { extraversion: 1, agreeableness: 1 } },
                        { text: "Drame psychologique", traits: { openness: 1, emotionalStability: 1 } },
                        { text: "Documentaire", traits: { conscientiousness: 1, openness: 1 } }
                    ]
                },
                {
                    q: "üçï Soir√©e id√©ale ?",
                    options: [
                        { text: "Grande f√™te", traits: { extraversion: 1, agreeableness: 1 } },
                        { text: "D√Æner intime", traits: { agreeableness: 1, emotionalStability: 1 } },
                        { text: "Projet personnel", traits: { conscientiousness: 1, openness: 1 } },
                        { text: "Repos total", traits: { emotionalStability: 1, conscientiousness: 1 } }
                    ]
                },
                {
                    q: "Ta forme d'art pr√©f√©r√©e ?",
                    options: [
                        { text: "Peinture", traits: { openness: 1, conscientiousness: 1 } },
                        { text: "Musique", traits: { openness: 1, emotionalStability: 1 } },
                        { text: "Danse", traits: { extraversion: 1, openness: 1 } },
                        { text: "√âcriture", traits: { openness: 1, conscientiousness: 1 } }
                    ]
                },
                {
                    q: "Ton plus grand r√™ve ?",
                    options: [
                        { text: "Changer le monde", traits: { extraversion: 1, agreeableness: 1 } },
                        { text: "Cr√©er quelque chose d'unique", traits: { openness: 1, conscientiousness: 1 } },
                        { text: "Vivre libre et heureux", traits: { emotionalStability: 1, openness: 1 } },
                        { text: "Ma√Ætriser mon domaine", traits: { conscientiousness: 1, extraversion: 1 } }
                    ]
                }
            ],

            currentQuestion: 0,
            results: {
                openness: 0,
                conscientiousness: 0,
                extraversion: 0,
                agreeableness: 0,
                emotionalStability: 0
            },

            start() {
                elements.warmupModal.classList.add('active');
                this.renderQuestion();
            },

            renderQuestion() {
                if (this.currentQuestion >= this.questions.length) {
                    this.showResults();
                    return;
                }

                const question = this.questions[this.currentQuestion];
                const container = document.getElementById('warmupQuestionContainer');
                
                // Progress dots
                let progressHTML = '';
                for (let i = 0; i < this.questions.length; i++) {
                    progressHTML += `<div class="warmup-dot ${i <= this.currentQuestion ? 'active' : ''}"></div>`;
                }
                document.getElementById('warmupProgress').innerHTML = progressHTML;

                // Question and options
                container.innerHTML = `
                    <div class="warmup-question">${question.q}</div>
                    <div class="warmup-options">
                        ${question.options.map((option, i) => `
                            <div class="warmup-option" onclick="Warmup.selectOption(${i})">
                                ${option.text}
                            </div>
                        `).join('')}
                    </div>
                `;
            },

            selectOption(index) {
                const question = this.questions[this.currentQuestion];
                const option = question.options[index];
                
                // Add traits
                Object.keys(option.traits).forEach(trait => {
                    this.results[trait] += option.traits[trait];
                });

                this.currentQuestion++;
                setTimeout(() => this.renderQuestion(), 300);
            },

            showResults() {
                const totalScore = Object.values(this.results).reduce((a, b) => a + b, 0);
                const dominant = Object.entries(this.results).sort((a, b) => b[1] - a[1])[0][0];
                
                const personalities = {
                    openness: { name: "Explorateur Cr√©atif", emoji: "", desc: "Tu es curieux, imaginatif et ouvert aux nouvelles exp√©riences" },
                    conscientiousness: { name: "Architecte Organis√©", emoji: "üìê", desc: "Tu es m√©thodique, fiable et tourn√© vers l'accomplissement" },
                    extraversion: { name: "Catalyseur Social", emoji: "", desc: "Tu es √©nergique, expressif et tu t'√©panouis avec les autres" },
                    agreeableness: { name: "Harmoniseur Empathique", emoji: "ü§ù", desc: "Tu es attentionn√©, coop√©ratif et soucieux des autres" },
                    emotionalStability: { name: "Sage √âquilibr√©", emoji: "üßò", desc: "Tu es calme, r√©silient et √©motionnellement stable" }
                };

                const personality = personalities[dominant];
                state.warmupResults = { ...this.results, dominant, personality };

                const container = document.getElementById('warmupQuestionContainer');
                container.innerHTML = `
                    <div class="warmup-result">
                        <h2>${personality.emoji} ${personality.name}</h2>
                        <p>${personality.desc}</p>
                        <p style="margin-top: 1rem; color: #64748b;">Pr√™t pour l'interview approfondie ?</p>
                        <button class="start-btn" onclick="Warmup.complete()">C'est parti !</button>
                    </div>
                `;

                Utils.showToast('Warm-up termin√© ! Profil pr√©liminaire cr√©√©.', 'success');
            },

            complete() {
                state.warmupCompleted = true;
                elements.warmupModal.classList.remove('active');
                startInterview();
            }
        };

        // ============================================
        // MODULE 3: REVELATIONS PROGRESSIVES
        // ============================================
        const Revelations = {
            milestones: [10, 20, 30, 40],
            unlockedBadges: [],

            check() {
                const responses = state.responseCount;
                
                // Update progress bar
                const progress = (responses / 40) * 100;
                elements.revelationsProgress.style.width = `${progress}%`;
                elements.currentResponses.textContent = responses;

                // Check for milestone unlocks
                this.milestones.forEach(milestone => {
                    if (responses >= milestone && !this.unlockedBadges.includes(milestone)) {
                        this.unlockBadge(milestone);
                    }
                });

                // Generate insights based on patterns
                if (responses === 10) this.generateInsight('early');
                if (responses === 20) this.generateInsight('mid');
                if (responses === 30) this.generateInsight('deep');
                if (responses === 40) this.generateInsight('final');
            },

            unlockBadge(milestone) {
                this.unlockedBadges.push(milestone);
                state.revelationsUnlocked++;
                elements.badgeCount.textContent = state.revelationsUnlocked;

                // Unlock badge visually
                const badgeElement = document.querySelector(`[data-milestone="${milestone}"]`);
                if (badgeElement) {
                    badgeElement.classList.remove('locked');
                    badgeElement.classList.add('unlocked');
                }

                // Get badge info
                const badges = {
                    10: { icon: "", title: "Explorer", message: "Premier jalon franchi ! Tu commences √† r√©v√©ler ta personnalit√©." },
                    20: { icon: "", title: "Introspectif", message: "Tu creuses en profondeur ! Tes r√©ponses deviennent plus riches." },
                    30: { icon: "", title: "Profond", message: "Impressionnant ! Tu explores des aspects profonds de toi-m√™me." },
                    40: { icon: "üèÜ", title: "Ma√Ætre", message: "Bravo ! Tu as compl√©t√© un profil exceptionnel !" }
                };

                const badge = badges[milestone];
                Utils.showToast(`Badge d√©bloqu√© : ${badge.icon} ${badge.title}`, 'success', badge.message);

                // Auto-open revelations panel
                setTimeout(() => {
                    elements.revelationsPanel.classList.add('open');
                }, 500);
            },

            generateInsight(stage) {
                const messages = state.messages.filter(m => m.role === 'user');
                const totalWords = messages.reduce((sum, m) => sum + m.content.split(' ').length, 0);
                const avgLength = totalWords / messages.length;

                let insight = '';

                if (stage === 'early') {
                    if (avgLength > 50) {
                        insight = "Tu t'exprimes de mani√®re d√©taill√©e et r√©fl√©chie. Continue ainsi !";
                    } else {
                        insight = "Tes r√©ponses sont concises. N'h√©site pas √† d√©velopper davantage.";
                    }
                }

                if (stage === 'mid') {
                    const emotionalWords = ['ressens', '√©motion', 'sentiment', 'heureux', 'triste', 'anxieux'];
                    const emotionalCount = messages.reduce((count, m) => {
                        return count + emotionalWords.filter(word => m.content.toLowerCase().includes(word)).length;
                    }, 0);

                    if (emotionalCount > 5) {
                        insight = "Tu partages tes √©motions avec authenticit√©. C'est tr√®s pr√©cieux.";
                    } else {
                        insight = "Tu restes factuel. Partager tes ressentis enrichirait ton profil.";
                    }
                }

                if (stage === 'deep') {
                    const exampleWords = ['par exemple', 'une fois', 'je me souviens', 'r√©cemment'];
                    const exampleCount = messages.reduce((count, m) => {
                        return count + exampleWords.filter(word => m.content.toLowerCase().includes(word)).length;
                    }, 0);

                    if (exampleCount > 3) {
                        insight = "Tes exemples concrets rendent ton clone tr√®s authentique !";
                    } else {
                        insight = "Ajouter des exemples concrets enrichirait encore ton profil.";
                    }
                }

                if (stage === 'final') {
                    insight = `Profil exceptionnel ! ${totalWords} mots, ${messages.length} r√©ponses. Ton clone sera d'une fid√©lit√© remarquable.`;
                }

                if (insight) {
                    const insightElement = document.createElement('div');
                    insightElement.className = 'insight-item slide-up';
                    insightElement.textContent = insight;
                    elements.insightsContainer.appendChild(insightElement);
                }
            }
        };

        // ============================================
        // MODULE 4: DEPTH GAUGE
        // ============================================
        const DepthGauge = {
            calculate() {
                const messages = state.messages.filter(m => m.role === 'user');
                if (messages.length === 0) return 0;

                let score = 0;
                let maxScore = 0;

                // Criterion 1: Average length (30 points)
                const totalWords = messages.reduce((sum, m) => sum + m.content.split(' ').length, 0);
                const avgLength = totalWords / messages.length;
                score += Math.min(avgLength / 10, 30);
                maxScore += 30;

                // Criterion 2: Vocabulary diversity (25 points)
                const allWords = messages.join(' ').toLowerCase().split(/\s+/);
                const uniqueWords = new Set(allWords);
                const diversity = (uniqueWords.size / allWords.length) * 100;
                score += Math.min(diversity * 0.4, 25);
                maxScore += 25;

                // Criterion 3: Emotional depth (20 points)
                const emotionalWords = ['ressens', '√©motion', 'sentiment', 'pense', 'crois', 'heureux', 'triste', 'anxieux', 'joie', 'peur'];
                const emotionalCount = messages.reduce((count, m) => {
                    return count + emotionalWords.filter(word => m.content.toLowerCase().includes(word)).length;
                }, 0);
                score += Math.min(emotionalCount * 2, 20);
                maxScore += 20;

                // Criterion 4: Concrete examples (15 points)
                const exampleWords = ['par exemple', 'une fois', 'je me souviens', 'r√©cemment', 'souvent'];
                const exampleCount = messages.reduce((count, m) => {
                    return count + exampleWords.filter(word => m.content.toLowerCase().includes(word)).length;
                }, 0);
                score += Math.min(exampleCount * 3, 15);
                maxScore += 15;

                // Criterion 5: Introspection depth (10 points)
                const introspectionWords = ['parce que', 'car', 'puisque', '√©tant donn√©', 'donc', 'ainsi'];
                const introspectionCount = messages.reduce((count, m) => {
                    return count + introspectionWords.filter(word => m.content.toLowerCase().includes(word)).length;
                }, 0);
                score += Math.min(introspectionCount * 2, 10);
                maxScore += 10;

                const percentage = Math.round((score / maxScore) * 100);
                return Math.min(percentage, 100);
            },

            update() {
                const percentage = this.calculate();
                elements.gaugeFill.style.height = `${percentage}%`;
                elements.gaugePercentage.textContent = `${percentage}%`;

                // Update color based on percentage
                if (percentage < 40) {
                    elements.gaugeFill.style.background = 'linear-gradient(to top, var(--gauge-low), var(--gauge-low))';
                } else if (percentage < 70) {
                    elements.gaugeFill.style.background = 'linear-gradient(to top, var(--gauge-low), var(--gauge-medium))';
                } else {
                    elements.gaugeFill.style.background = 'linear-gradient(to top, var(--gauge-low), var(--gauge-medium), var(--gauge-high))';
                }

                // Show encouraging message if low
                if (percentage < 50 && state.responseCount > 5 && state.responseCount % 5 === 0) {
                    Utils.showToast('D√©veloppe davantage tes r√©ponses pour enrichir ton profil !', 'info');
                }
            }
        };

        // ============================================
        // MODULE 5: CONTRADICTION DETECTOR
        // ============================================
        const ContradictionDetector = {
            statements: [],

            analyze(newMessage) {
                // Extract strong statements
                const strongPatterns = [
                    /je suis (tr√®s |plut√¥t |vraiment )?(.*)/gi,
                    /j'(aime|adore|d√©teste|pr√©f√®re) (.*)/gi,
                    /je (ne |n')?(.*) (jamais|toujours|souvent|rarement)/gi
                ];

                strongPatterns.forEach(pattern => {
                    const matches = newMessage.content.matchAll(pattern);
                    for (const match of matches) {
                        this.statements.push({
                            text: match[0],
                            messageIndex: state.messages.length - 1,
                            context: newMessage.content.substring(Math.max(0, match.index - 50), Math.min(newMessage.content.length, match.index + 100))
                        });
                    }
                });

                // Check for contradictions
                if (this.statements.length > 5) {
                    this.detectContradictions();
                }
            },

            detectContradictions() {
                // Simple contradiction detection
                console.log('Statements analyzed:', this.statements.length);
            }
        };

        // ============================================
        // MODULE 6: MICRO-EXPRESSIONS ANALYZER
        // ============================================
        const MicroExpressions = {
            analyze() {
                const messages = state.messages.filter(m => m.role === 'user');
                
                return {
                    pronouns: this.analyzePronouns(messages),
                    tenses: this.analyzeTenses(messages),
                    abstractness: this.analyzeAbstractness(messages),
                    negations: this.analyzeNegations(messages)
                };
            },

            analyzePronouns(messages) {
                const text = messages.map(m => m.content).join(' ').toLowerCase();
                const jeCount = (text.match(/\bje\b/g) || []).length;
                const nousCount = (text.match(/\bnous\b/g) || []).length;
                const onCount = (text.match(/\bon\b/g) || []).length;
                
                return {
                    je: jeCount,
                    nous: nousCount,
                    on: onCount,
                    ratio: jeCount / (nousCount + onCount + 1)
                };
            },

            analyzeTenses(messages) {
                const text = messages.map(m => m.content).join(' ').toLowerCase();
                const pastMarkers = ['√©tais', 'avais', 'faisais', 'ai √©t√©', 'ai fait'];
                const presentMarkers = ['suis', 'ai', 'fais', 'vais'];
                const futureMarkers = ['serai', 'aurai', 'ferai', 'vais'];
                
                let past = 0, present = 0, future = 0;
                pastMarkers.forEach(marker => past += (text.match(new RegExp(marker, 'g')) || []).length);
                presentMarkers.forEach(marker => present += (text.match(new RegExp(marker, 'g')) || []).length);
                futureMarkers.forEach(marker => future += (text.match(new RegExp(marker, 'g')) || []).length);
                
                return { past, present, future };
            },

            analyzeAbstractness(messages) {
                const text = messages.map(m => m.content).join(' ').toLowerCase();
                const abstractWords = ['concept', 'id√©e', 'th√©orie', 'principe', 'valeur', 'croyance'];
                const concreteWords = ['par exemple', 'une fois', 'r√©cemment', 'hier', 'moment'];
                
                let abstract = 0, concrete = 0;
                abstractWords.forEach(word => abstract += (text.match(new RegExp(word, 'g')) || []).length);
                concreteWords.forEach(word => concrete += (text.match(new RegExp(word, 'g')) || []).length);
                
                return { abstract, concrete, ratio: abstract / (concrete + 1) };
            },

            analyzeNegations(messages) {
                const text = messages.map(m => m.content).join(' ').toLowerCase();
                const negations = (text.match(/\b(ne |n'|pas |jamais |rien |personne )/g) || []).length;
                const totalWords = text.split(/\s+/).length;
                
                return {
                    count: negations,
                    percentage: (negations / totalWords) * 100
                };
            }
        };

        // ============================================
        // MODULE 7: CONTEXTUAL ANALYSIS
        // ============================================
        const ContextualAnalysis = {
            contexts: {
                professional: { name: "Professionnel", icon: "üíº", questions: [] },
                intimate: { name: "Intime", icon: "‚ù§Ô∏è", questions: [] },
                social: { name: "Social", icon: "üë•", questions: [] },
                solitary: { name: "Solitaire", icon: "üßò", questions: [] },
                stress: { name: "Sous stress", icon: "", questions: [] }
            },

            detectContext(question) {
                const q = question.toLowerCase();
                
                if (q.includes('travail') || q.includes('professionnel') || q.includes('coll√®gue')) {
                    return 'professional';
                }
                if (q.includes('proche') || q.includes('intime') || q.includes('ami') || q.includes('famille')) {
                    return 'intimate';
                }
                if (q.includes('groupe') || q.includes('social') || q.includes('r√©union')) {
                    return 'social';
                }
                if (q.includes('seul') || q.includes('solitaire') || q.includes('isol√©')) {
                    return 'solitary';
                }
                if (q.includes('stress') || q.includes('pression') || q.includes('difficult√©')) {
                    return 'stress';
                }
                
                return null;
            },

            addResponse(context, question, response) {
                if (!this.contexts[context]) return;
                
                this.contexts[context].questions.push({
                    question,
                    response,
                    timestamp: Date.now()
                });
                
                state.contexts[context] = this.contexts[context];
            }
        };

        // ============================================
        // MODULE 8: VOICE RECOGNITION
        // ============================================
        const VoiceRecognition = {
            recognition: null,
            isListening: false,
            finalTranscript: '',
            interimTranscript: '',

            init() {
                // Check browser support
                if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                    console.warn('Speech recognition not supported');
                    elements.voiceBtn.style.display = 'none';
                    return false;
                }

                // Initialize recognition
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                this.recognition = new SpeechRecognition();
                
                this.recognition.continuous = true;
                this.recognition.interimResults = true;
                this.recognition.lang = 'fr-FR';
                this.recognition.maxAlternatives = 1;

                // Event handlers
                this.recognition.onstart = () => {
                    this.isListening = true;
                    elements.voiceBtn.classList.add('recording');
                    elements.voiceBtn.textContent = 'üî¥';
                    elements.voiceBtn.title = 'Arr√™ter la dict√©e';
                    Utils.showToast('Dict√©e vocale activ√©e', 'info', 'Parlez maintenant...');
                };

                this.recognition.onend = () => {
                    this.isListening = false;
                    elements.voiceBtn.classList.remove('recording');
                    elements.voiceBtn.textContent = 'üé§';
                    elements.voiceBtn.title = 'Dict√©e vocale';
                };

                this.recognition.onerror = (event) => {
                    console.error('Speech recognition error:', event.error);
                    this.isListening = false;
                    elements.voiceBtn.classList.remove('recording');
                    elements.voiceBtn.textContent = 'üé§';
                    
                    let errorMessage = 'Erreur de reconnaissance vocale';
                    
                    switch(event.error) {
                        case 'no-speech':
                            errorMessage = 'Aucune parole d√©tect√©e. R√©essayez.';
                            break;
                        case 'audio-capture':
                            errorMessage = 'Microphone non accessible. V√©rifiez les permissions.';
                            break;
                        case 'not-allowed':
                            errorMessage = 'Permission microphone refus√©e. Autorisez l\'acc√®s dans votre navigateur.';
                            break;
                        case 'network':
                            errorMessage = 'Erreur r√©seau. V√©rifiez votre connexion.';
                            break;
                    }
                    
                    Utils.showToast(errorMessage, 'danger');
                };

                this.recognition.onresult = (event) => {
                    let interimTranscript = '';
                    let finalTranscript = '';

                    // Parcourir tous les r√©sultats depuis le d√©but
                    for (let i = 0; i < event.results.length; i++) {
                        const transcript = event.results[i][0].transcript;
                        
                        if (event.results[i].isFinal) {
                            finalTranscript += transcript + ' ';
                        } else {
                            interimTranscript += transcript;
                        }
                    }

                    // Combiner le texte initial (avant le start) avec les nouveaux r√©sultats
                    const fullText = this.finalTranscript + finalTranscript + interimTranscript;
                    
                    // Update textarea
                    elements.inputArea.value = fullText.trim();
                    
                    // Sauvegarder le texte finalis√© (sans interim)
                    if (finalTranscript) {
                        this.finalTranscript += finalTranscript;
                    }
                    
                    // Auto-resize
                    elements.inputArea.style.height = 'auto';
                    elements.inputArea.style.height = (elements.inputArea.scrollHeight) + 'px';
                    
                    // Visual feedback - bordure color√©e si texte temporaire
                    if (interimTranscript) {
                        elements.inputArea.style.borderColor = 'var(--primary)';
                    } else {
                        elements.inputArea.style.borderColor = '';
                    }
                };

                return true;
            },

            toggle() {
                if (!this.recognition) {
                    Utils.showToast('Reconnaissance vocale non disponible', 'danger', 'Votre navigateur ne supporte pas cette fonctionnalit√©');
                    return;
                }

                if (this.isListening) {
                    this.stop();
                } else {
                    this.start();
                }
            },

            start() {
                try {
                    // Sauvegarder le texte qui existe d√©j√† dans textarea
                    this.finalTranscript = elements.inputArea.value ? elements.inputArea.value + ' ' : '';
                    this.interimTranscript = '';
                    this.recognition.start();
                } catch (error) {
                    console.error('Failed to start recognition:', error);
                    Utils.showToast('Impossible de d√©marrer la dict√©e', 'danger');
                }
            },

            stop() {
                try {
                    this.recognition.stop();
                    Utils.showToast('Dict√©e vocale arr√™t√©e', 'info');
                } catch (error) {
                    console.error('Failed to stop recognition:', error);
                }
            }
        };

        // ============================================
        // MODULE 9: AVATAR P5.JS
        // ============================================
        const Avatar = {
            // Configuration
            config: {
                canvasWidth: 280,
                canvasHeight: 280,
                baseSize: 65,           // R√©duit de 90 ‚Üí 65 (plus d'espace autour)
                particleCount: 35,      // Un peu plus de particules
                animationSpeed: 0.015,  // L√©g√®rement plus lent pour mieux voir
            },

            // State
            state: {
                p5Instance: null,
                mode: 'hybrid', // 'hybrid' or 'generative'
                userPhoto: null,
                currentTraits: {
                    openness: 7,              // Plus d'ouverture = plus de couleurs
                    conscientiousness: 6,     // Un peu plus structur√©
                    extraversion: 6,          // Mouvement mod√©r√©
                    agreeableness: 7,         // Forme douce
                    emotionalStability: 6     // Stable mais pas rigide
                },
                targetTraits: {},
                morphProgress: 0,
                particles: [],
                time: 0
            },

            // Initialization
            init(containerElement = null) {
                const container = containerElement || document.getElementById('avatar');
                if (!container) {
                    console.error('Avatar: Container element not found');
                    return;
                }

                // Create p5 instance
                const sketch = (p) => {
                    p.setup = () => {
                        const canvas = p.createCanvas(this.config.canvasWidth, this.config.canvasHeight);
                        canvas.parent(container);
                        p.colorMode(p.HSB, 360, 100, 100, 100);
                        
                        // Initialize particles
                        this.initParticles(p);
                    };

                    p.draw = () => {
                        // Clear background (transparent in hybrid mode)
                        if (this.state.mode === 'hybrid') {
                            p.clear(); // Transparent background
                        } else {
                            p.background(0, 0, 100, 20); // Light background for generative
                        }
                        
                        // Update time
                        this.state.time += this.config.animationSpeed;
                        
                        // Morph traits if needed
                        if (this.state.morphProgress < 1) {
                            this.morphTraits();
                        }
                        
                        // Draw avatar
                        p.push();
                        p.translate(p.width / 2, p.height / 2);
                        
                        if (this.state.mode === 'hybrid') {
                            // Hybrid mode: only draw effects (border, particles, aura)
                            this.drawHybridEffects(p);
                        } else {
                            // Generative mode: draw full form + particles
                            this.drawMainForm(p);
                            this.drawParticles(p);
                        }
                        
                        p.pop();
                    };
                };

                this.state.p5Instance = new p5(sketch);
            },

            // Update traits
            update(traits) {
                // Normalize traits to 0-10 scale
                const normalized = {};
                Object.keys(traits).forEach(key => {
                    normalized[key] = this.normalize(traits[key], 0, 10);
                });

                // Set target traits for morphing
                this.state.targetTraits = normalized;
                this.state.morphProgress = 0;

                // Update UI
                this.updateUI(normalized);
            },

            normalize(value, min, max) {
                if (value < min) return min;
                if (value > max) return max;
                return value;
            },

            morphTraits() {
                this.state.morphProgress += 0.02;
                if (this.state.morphProgress > 1) {
                    this.state.morphProgress = 1;
                }

                // Interpolate between current and target traits
                Object.keys(this.state.targetTraits).forEach(key => {
                    const current = this.state.currentTraits[key];
                    const target = this.state.targetTraits[key];
                    this.state.currentTraits[key] = current + (target - current) * this.state.morphProgress;
                });
            },

            // Draw main form
            drawMainForm(p) {
                const traits = this.state.currentTraits;
                const t = this.state.time;

                // Get colors based on openness
                const colors = this.getColors(traits.openness);
                
                // Get shape complexity based on conscientiousness
                const complexity = this.getComplexity(traits.conscientiousness);
                
                // Get motion amplitude based on extraversion
                const motionAmp = this.getMotionAmplitude(traits.extraversion);
                
                // Get softness based on agreeableness
                const softness = this.getSoftness(traits.agreeableness);
                
                // Get stability based on emotional stability
                const stability = this.getStability(traits.emotionalStability);

                // Draw main shape
                // Multiple layers for depth
                for (let layer = 0; layer < 3; layer++) {
                    p.push();
                    
                    // Color with transparency (augment√© de 30 ‚Üí 40 pour plus de visibilit√©)
                    const col = colors[layer % colors.length];
                    const alpha = layer === 0 ? 50 : (layer === 1 ? 40 : 30); // Layer principal plus visible
                    
                    // Contour sur le premier layer seulement pour mieux d√©finir la forme
                    if (layer === 0) {
                        p.strokeWeight(1.5);
                        p.stroke(col.h, col.s, Math.max(col.b - 15, 0), 60);
                    } else {
                        p.noStroke();
                    }
                    
                    p.fill(col.h, col.s, col.b, alpha);
                    
                    // Rotate based on time and stability
                    const rotation = t * (0.5 - stability * 0.04);
                    p.rotate(rotation);
                    
                    // Scale based on layer
                    const scale = 1 - layer * 0.15;
                    p.scale(scale);
                    
                    // Draw organic shape
                    p.beginShape();
                    for (let i = 0; i < complexity; i++) {
                        const angle = (i / complexity) * p.TWO_PI;
                        
                        // Base radius
                        let radius = this.config.baseSize;
                        
                        // Add motion based on extraversion
                        radius += p.sin(angle * 2 + t) * motionAmp;
                        radius += p.cos(angle * 3 - t * 0.5) * (motionAmp * 0.5);
                        
                        // Add softness based on agreeableness
                        radius += p.sin(angle * softness + t) * 10;
                        
                        // Add variation based on stability
                        const variation = p.noise(
                            p.cos(angle) + t * (1 - stability),
                            p.sin(angle) + t * (1 - stability)
                        ) * 20;
                        radius += variation;
                        
                        const x = p.cos(angle) * radius;
                        const y = p.sin(angle) * radius;
                        p.vertex(x, y);
                    }
                    p.endShape(p.CLOSE);
                    
                    p.pop();
                }
            },

            // Initialize particles
            initParticles(p) {
                this.state.particles = [];
                for (let i = 0; i < this.config.particleCount; i++) {
                    this.state.particles.push({
                        angle: p.random(p.TWO_PI),
                        radius: p.random(40, 130),
                        speed: p.random(0.001, 0.005),
                        size: p.random(2, 5),
                        alpha: p.random(30, 60)
                    });
                }
            },

            // Draw particles
            drawParticles(p) {
                const traits = this.state.currentTraits;
                const colors = this.getColors(traits.openness);

                this.state.particles.forEach((particle, i) => {
                    // Update particle position
                    particle.angle += particle.speed;
                    
                    // Modulate radius based on time and extraversion
                    const radiusMod = p.sin(this.state.time + i) * (traits.extraversion * 1.5);
                    const currentRadius = particle.radius + radiusMod;
                    
                    const x = p.cos(particle.angle) * currentRadius;
                    const y = p.sin(particle.angle) * currentRadius;
                    
                    // Get color
                    const col = colors[i % colors.length];
                    
                    // Draw particle
                    p.noStroke();
                    p.fill(col.h, col.s, col.b, particle.alpha);
                    p.circle(x, y, particle.size);
                    
                    // Draw glow if high extraversion
                    if (traits.extraversion > 7) {
                        p.fill(col.h, col.s, col.b, 15);
                        p.circle(x, y, particle.size * 2);
                    }
                });
            },

            // Trait mappings
            getColors(openness) {
                // Openness determines color palette - Institut du Couple
                if (openness > 7) {
                    return [
                        { h: 183, s: 19, b: 69 },   // Mer #8FAFB1
                        { h: 100, s: 6, b: 82 },    // Vert Sauge #C8D0C3
                        { h: 40, s: 15, b: 85 },    // Beige Sable #D8CDBB
                        { h: 35, s: 16, b: 90 }     // Sable #E6D7C3
                    ];
                } else if (openness > 4) {
                    return [
                        { h: 183, s: 19, b: 69 },   // Mer #8FAFB1
                        { h: 100, s: 6, b: 82 },    // Vert Sauge #C8D0C3
                        { h: 35, s: 16, b: 90 }     // Sable #E6D7C3
                    ];
                } else {
                    return [
                        { h: 40, s: 15, b: 85 },    // Beige Sable #D8CDBB
                        { h: 35, s: 16, b: 90 },    // Sable #E6D7C3
                        { h: 30, s: 10, b: 75 }     // Beige fonc√©
                    ];
                }
            },

            getComplexity(conscientiousness) {
                if (conscientiousness > 7) return 8;      // Tr√®s g√©om√©trique
                else if (conscientiousness > 5) return 10; // Semi-g√©om√©trique (chang√© de 12)
                else return 16;                            // Organique mais pas trop (chang√© de 20)
            },

            getMotionAmplitude(extraversion) {
                // R√©duit de 8-33px √† 5-22px pour mouvements plus contr√¥l√©s
                return 5 + (extraversion / 10) * 17;
            },

            getSoftness(agreeableness) {
                return 2 + (agreeableness / 10) * 4;
            },

            getStability(emotionalStability) {
                return emotionalStability / 10;
            },

            // Update UI
            updateUI(traits) {
                const traitNames = ['openness', 'conscientiousness', 'extraversion', 'agreeableness', 'emotionalStability'];
                
                traitNames.forEach(trait => {
                    const value = traits[trait];
                    const displayElement = document.getElementById(`trait${trait.charAt(0).toUpperCase() + trait.slice(1)}`);
                    const barElement = document.getElementById(`bar${trait.charAt(0).toUpperCase() + trait.slice(1)}`);
                    
                    if (displayElement) {
                        displayElement.textContent = value.toFixed(1);
                    }
                    if (barElement) {
                        barElement.style.width = `${(value / 10) * 100}%`;
                    }
                });
            },

            // Draw hybrid effects (border + particles + aura)
            drawHybridEffects(p) {
                const traits = this.state.currentTraits;
                const t = this.state.time;
                const colors = this.getColors(traits.openness);
                
                // 1. Draw animated border
                p.noFill();
                p.strokeWeight(3 + Math.sin(t * 2) * 1.5); // Pulsating width
                const col = colors[0]; // Mer color
                p.stroke(col.h, col.s, col.b, 70 + Math.sin(t) * 10); // Pulsating opacity
                p.circle(0, 0, 135); // Circular border around photo
                
                // 2. Draw outer aura
                p.strokeWeight(15);
                p.stroke(col.h, col.s, col.b, 15 + Math.sin(t * 0.5) * 5);
                p.circle(0, 0, 150 + Math.sin(t) * 5);
                
                // 3. Draw particles orbiting
                const particleColors = this.getColors(traits.openness);
                this.state.particles.forEach((particle, i) => {
                    particle.angle += particle.speed;
                    
                    // Orbit radius (outside the photo circle)
                    const radiusMod = Math.sin(t + i) * (traits.extraversion * 1.5);
                    const currentRadius = particle.radius + radiusMod;
                    
                    const x = Math.cos(particle.angle) * currentRadius;
                    const y = Math.sin(particle.angle) * currentRadius;
                    
                    const particleCol = particleColors[i % particleColors.length];
                    p.noStroke();
                    p.fill(particleCol.h, particleCol.s, particleCol.b, particle.alpha);
                    p.circle(x, y, particle.size);
                    
                    // Glow for high extraversion
                    if (traits.extraversion > 7) {
                        p.fill(particleCol.h, particleCol.s, particleCol.b, 20);
                        p.circle(x, y, particle.size * 2);
                    }
                });
                
                // 4. Draw subtle rays based on agreeableness
                if (traits.agreeableness > 6) {
                    const rayCount = Math.floor(2 + (traits.agreeableness / 10) * 4);
                    p.strokeWeight(2);
                    for (let i = 0; i < rayCount; i++) {
                        const angle = (i / rayCount) * p.TWO_PI + t * 0.3;
                        const rayLength = 70 + Math.sin(t * 2 + i) * 10;
                        p.stroke(colors[1].h, colors[1].s, colors[1].b, 30);
                        p.line(0, 0, Math.cos(angle) * rayLength, Math.sin(angle) * rayLength);
                    }
                }
            },

            // Set mode (hybrid or generative)
            setMode(mode) {
                this.state.mode = mode;
                console.log(`üé® Avatar mode: ${mode}`);
                
                // Show/hide photo layer
                const photoLayer = document.getElementById('avatarPhotoLayer');
                if (photoLayer) {
                    if (mode === 'hybrid' && this.state.userPhoto) {
                        photoLayer.classList.add('active');
                    } else {
                        photoLayer.classList.remove('active');
                    }
                }
            },

            // Load user photo
            loadUserPhoto(file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    this.state.userPhoto = e.target.result;
                    
                    // Update photo layer
                    const photoLayer = document.getElementById('avatarPhotoLayer');
                    if (photoLayer) {
                        photoLayer.style.backgroundImage = `url(${e.target.result})`;
                        
                        // If in hybrid mode, show the photo
                        if (this.state.mode === 'hybrid') {
                            photoLayer.classList.add('active');
                        }
                    }
                    
                    // Save to localStorage
                    localStorage.setItem('avatar_photo', e.target.result);
                    
                    // Show remove button
                    const removeBtn = document.getElementById('avatarRemoveBtn');
                    if (removeBtn) removeBtn.style.display = 'flex';
                    
                    // Show export button
                    const exportBtn = document.getElementById('avatarExportBtn');
                    if (exportBtn) exportBtn.style.display = 'block';
                    
                    console.log('Photo uploaded and saved');
                    Utils.showToast('Photo charg√©e avec succ√®s', 'success');
                };
                reader.readAsDataURL(file);
            },

            // Remove user photo
            removeUserPhoto() {
                this.state.userPhoto = null;
                
                // Hide photo layer
                const photoLayer = document.getElementById('avatarPhotoLayer');
                if (photoLayer) {
                    photoLayer.classList.remove('active');
                    photoLayer.style.backgroundImage = '';
                }
                
                // Remove from localStorage
                localStorage.removeItem('avatar_photo');
                
                // Hide remove button
                const removeBtn = document.getElementById('avatarRemoveBtn');
                if (removeBtn) removeBtn.style.display = 'none';
                
                // Hide export button
                const exportBtn = document.getElementById('avatarExportBtn');
                if (exportBtn) exportBtn.style.display = 'none';
                
                // Switch to generative mode
                this.setMode('generative');
                const modeGenerative = document.getElementById('modeGenerative');
                const modeHybrid = document.getElementById('modeHybrid');
                if (modeGenerative) modeGenerative.classList.add('active');
                if (modeHybrid) modeHybrid.classList.remove('active');
                
                console.log('Photo removed');
                Utils.showToast('Photo supprim√©e', 'info');
            },

            // Export avatar as PNG
            exportAvatar() {
                const userName = localStorage.getItem('avatar_name') || 'Avatar';
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                // Canvas size
                canvas.width = 280;
                canvas.height = 320; // Extra space for name
                
                // Background (Sable)
                ctx.fillStyle = '#E6D7C3';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                if (this.state.mode === 'hybrid' && this.state.userPhoto) {
                    // HYBRID MODE: Photo + Effects
                    
                    // 1. Draw photo (circular)
                    const photoImg = new Image();
                    photoImg.crossOrigin = 'anonymous';
                    photoImg.src = this.state.userPhoto;
                    
                    photoImg.onload = () => {
                        // Save context
                        ctx.save();
                        
                        // Create circular clipping path
                        ctx.beginPath();
                        ctx.arc(140, 140, 130, 0, Math.PI * 2);
                        ctx.closePath();
                        ctx.clip();
                        
                        // Draw photo
                        ctx.drawImage(photoImg, 10, 10, 260, 260);
                        
                        // Restore context
                        ctx.restore();
                        
                        // 2. Draw p5.js effects overlay
                        const p5Canvas = document.querySelector('#avatar canvas');
                        if (p5Canvas) {
                            ctx.drawImage(p5Canvas, 0, 0, 280, 280);
                        }
                        
                        // 3. Add name at bottom
                        ctx.fillStyle = '#333';
                        ctx.font = '16px system-ui, sans-serif';
                        ctx.textAlign = 'center';
                        ctx.fillText(userName, 140, 305);
                        
                        // Download
                        this.downloadCanvas(canvas, userName);
                    };
                    
                    photoImg.onerror = () => {
                        Utils.showToast('Erreur lors de l\'export de la photo', 'danger');
                    };
                    
                } else {
                    // GENERATIVE MODE: p5.js only
                    
                    const p5Canvas = document.querySelector('#avatar canvas');
                    if (p5Canvas) {
                        // Draw p5.js canvas
                        ctx.drawImage(p5Canvas, 0, 0, 280, 280);
                        
                        // Add name at bottom
                        ctx.fillStyle = '#333';
                        ctx.font = '16px system-ui, sans-serif';
                        ctx.textAlign = 'center';
                        ctx.fillText(userName, 140, 305);
                        
                        // Download
                        this.downloadCanvas(canvas, userName);
                    } else {
                        Utils.showToast('Erreur lors de l\'export', 'danger');
                    }
                }
            },

            // Helper: Download canvas as PNG
            downloadCanvas(canvas, name) {
                canvas.toBlob((blob) => {
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.download = `avatar-${name.toLowerCase().replace(/\s+/g, '-')}.png`;
                    link.href = url;
                    link.click();
                    URL.revokeObjectURL(url);
                    
                    Utils.showToast('Avatar t√©l√©charg√© avec succ√®s', 'success');
                });
            },

            // Load photo from localStorage
            loadSavedPhoto() {
                const savedPhoto = localStorage.getItem('avatar_photo');
                if (savedPhoto) {
                    this.state.userPhoto = savedPhoto;
                    const photoLayer = document.getElementById('avatarPhotoLayer');
                    if (photoLayer) {
                        photoLayer.style.backgroundImage = `url(${savedPhoto})`;
                        if (this.state.mode === 'hybrid') {
                            photoLayer.classList.add('active');
                        }
                    }
                    
                    // Show remove button
                    const removeBtn = document.getElementById('avatarRemoveBtn');
                    if (removeBtn) removeBtn.style.display = 'flex';
                    
                    // Show export button
                    const exportBtn = document.getElementById('avatarExportBtn');
                    if (exportBtn) exportBtn.style.display = 'block';
                    
                    console.log('Photo loaded from storage');
                    return true;
                }
                return false;
            },

            // Utilities
            destroy() {
                if (this.state.p5Instance) {
                    this.state.p5Instance.remove();
                    this.state.p5Instance = null;
                }
            }
        };

        // ============================================
        // API COMMUNICATION
        // ============================================
        async function sendToAPI(userMessage) {
            elements.typingIndicator.classList.add('active');
            elements.sendBtn.disabled = true;

            try {
                const response = await fetch(CONFIG.WORKER_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        model: CONFIG.MODEL,
                        max_tokens: CONFIG.MAX_TOKENS,
                        messages: state.messages
                    })
                });

                if (!response.ok) {
                    throw new Error(`API Error: ${response.status}`);
                }

                const data = await response.json();
                return data.content[0].text;

            } catch (error) {
                console.error('API Error:', error);
                Utils.showToast('Erreur de connexion. V√©rifiez votre configuration.', 'danger');
                return null;
            } finally {
                elements.typingIndicator.classList.remove('active');
                elements.sendBtn.disabled = false;
            }
        }

        // ============================================
        // MESSAGE HANDLING
        // ============================================
        function addMessage(role, content, messageId = null) {
            state.messages.push({ role, content, id: messageId });

            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${role}`;
            if (messageId) {
                messageDiv.id = messageId;
            }
            messageDiv.innerHTML = `
                <div class="message-avatar">${role === 'assistant' ? 'C' : 'V'}</div>
                <div class="message-content">${content}</div>
            `;

            elements.messages.appendChild(messageDiv);
            elements.messages.scrollTop = elements.messages.scrollHeight;

            if (role === 'user') {
                state.responseCount++;
                state.totalWords += Utils.countWords(content);
                Utils.updateStats();
                
                // Update modules
                Revelations.check();
                DepthGauge.update();
                ContradictionDetector.analyze({ role, content });
                
                // Detect context
                const lastAssistantMsg = [...state.messages].reverse().find(m => m.role === 'assistant');
                if (lastAssistantMsg) {
                    const context = ContextualAnalysis.detectContext(lastAssistantMsg.content);
                    if (context) {
                        ContextualAnalysis.addResponse(context, lastAssistantMsg.content, content);
                    }
                }
            }

            if (role === 'assistant') {
                state.questionCount++;
                Utils.updateStats();
            }

            // Auto-save
            saveProgress();
        }

        async function sendMessage() {
            const message = elements.inputArea.value.trim();
            if (!message) return;

            // Paraverbal: End capture et analyze
            Paraverbal.endCapture();
            Paraverbal.analyzeMessage(message);
            Paraverbal.updateDisplay();

            // MODULE 13: Store user message in Long-Term Memory
            await LongTermMemory.store(message, 'user');

            addMessage('user', message);
            elements.inputArea.value = '';
            elements.inputArea.style.height = 'auto';

            // Update avatar every 3 responses
            if (state.responseCount % 3 === 0) {
                updateAvatarTraits();
            }

            // Paraverbal insights every 5 messages
            if (state.responseCount % 5 === 0) {
                const insights = Paraverbal.getInsights();
                if (insights && insights.length > 0) {
                    insights.forEach(insight => {
                        const insightEl = document.createElement('div');
                        insightEl.className = 'insight-item';
                        insightEl.textContent = insight;
                        elements.insightsContainer.appendChild(insightEl);
                    });
                }
            }

            // MODULE 13: Enrich prompt with memory context
            let enrichedMessage = message;
            if (state.responseCount > 5) {
                const memoryEnrichment = await LongTermMemory.enrichPrompt(message, message);
                if (memoryEnrichment.memoryUsed) {
                    enrichedMessage = memoryEnrichment.prompt;
                    console.log('üß† Using memory context');
                }
            }

            const response = await sendToAPI(enrichedMessage);
            if (response) {
                // MODULE 13: Inject micro-expressions in response
                let finalResponse = response;
                if (state.responseCount > 10) {
                    finalResponse = TextualMicroExpressions.inject(response);
                    finalResponse = TextualMicroExpressions.addNaturalVariation(finalResponse);
                }
                
                const messageId = `msg-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                addMessage('assistant', finalResponse, messageId);
                
                // MODULE 13: Store assistant response in Long-Term Memory
                await LongTermMemory.store(finalResponse, 'assistant', { messageId });
                
                // Feedback System: Check if should ask feedback
                const feedbackDecision = await FeedbackSystem.shouldAskFeedback({ id: messageId, content: finalResponse });
                if (feedbackDecision.should) {
                    setTimeout(() => {
                        FeedbackSystem.askConversationalFeedback(messageId);
                    }, 3000 + Math.random() * 5000);
                }
                
                // Calculate concordance after 10+ responses
                if (state.responseCount >= 10 && state.responseCount % 10 === 0) {
                    setTimeout(async () => {
                        const score = await ConcordanceSystem.calculateConcordance();
                        ConcordanceSystem.updateDisplay();
                        
                        // Show concordance section
                        const concordanceSection = document.getElementById('concordanceSection');
                        if (concordanceSection) {
                            concordanceSection.style.display = 'block';
                        }
                        
                        // Show improve button if score < 85%
                        const improveBtn = document.getElementById('improveConcordanceBtn');
                        if (improveBtn && score < 85) {
                            improveBtn.style.display = 'block';
                        }
                        
                        // Check activation status
                        const status = ConcordanceSystem.getStatus();
                        if (!status.active) {
                            Utils.showToast(
                                `‚ö†Ô∏è Concordance : ${score.toFixed(1)}% - ${status.message}`,
                                'warning'
                            );
                        } else if (score >= 75 && score < 85) {
                            Utils.showToast(
                                `‚úÖ Clone activ√© ! Concordance : ${score.toFixed(1)}%`,
                                'success'
                            );
                        } else if (score >= 85) {
                            Utils.showToast(
                                `‚≠ê Clone optimal ! Concordance : ${score.toFixed(1)}%`,
                                'success'
                            );
                        }
                    }, 1000);
                }
                
                // MODULE 13: Learn tics every 15 messages
                if (state.responseCount > 15 && state.responseCount % 15 === 0) {
                    const userMessages = state.messages.filter(m => m.role === 'user');
                    const learned = TextualMicroExpressions.learn(userMessages);
                    if (learned.length > 0) {
                        console.log(`üéØ Learned ${learned.length} personal tics`);
                        // Update intelligence display
                        updateIntelligenceDisplay();
                    }
                }
                
                // MODULE 13: Update intelligence display every 10 messages
                if (state.responseCount >= 10 && state.responseCount % 10 === 0) {
                    setTimeout(() => {
                        updateIntelligenceDisplay();
                    }, 1500);
                }
            }
        }

        // ============================================
        // INITIALIZATION
        // ============================================
        // ============================================
        // AVATAR TRAITS CALCULATION
        // ============================================
        function updateAvatarTraits() {
            // Simple trait calculation based on conversation metrics
            // This can be enhanced with more sophisticated analysis
            
            const responseCount = state.responseCount;
            const avgWordCount = state.totalWords / Math.max(responseCount, 1);
            const conversationDepth = (state.currentPhase / state.totalPhases) * 10;
            
            // Calculate traits (simplified version)
            const traits = {
                // Openness: based on vocabulary richness and depth
                openness: Math.min(10, 3 + conversationDepth * 0.5 + (avgWordCount > 50 ? 2 : 0)),
                
                // Conscientiousness: based on response length consistency
                conscientiousness: Math.min(10, 4 + (avgWordCount > 30 ? 2 : 0) + (responseCount > 10 ? 1 : 0)),
                
                // Extraversion: based on response energy (word count)
                extraversion: Math.min(10, 3 + (avgWordCount / 20)),
                
                // Agreeableness: baseline with slight variation
                agreeableness: Math.min(10, 5 + Math.random() * 2),
                
                // Emotional Stability: increases with engagement
                emotionalStability: Math.min(10, 4 + (responseCount / 10))
            };
            
            // Update avatar
            Avatar.update(traits);
            
            console.log('üé® Avatar traits updated:', traits);
        }

        // ============================================
        // MODULE 10: ANALYSE PARAVERBALE
        // ============================================
        const Paraverbal = {
            state: {
                // Rythme d'√©criture
                compositionTimes: [],       // dur√©e totale par message
                currentMessageStart: null,  // timestamp d√©but message actuel
                
                // Expressivit√©
                punctuation: {
                    exclamation: 0,         // !
                    question: 0,            // ?
                    ellipsis: 0,            // ...
                    allCapsWords: 0,        // MOTS EN MAJUSCULES
                },
                emojisUsed: {},             // emoji ‚Üí count
                sentenceLengths: [],        // longueur de chaque phrase
                
                // Profondeur
                wordsPerMessage: [],        // longueur de chaque message
                vocabularyUnique: new Set(),// mots uniques
                exampleMarkers: 0,          // "par exemple", "comme", etc.
                reflectionMarkers: 0,       // "je pense", "je ressens", etc.
                nuanceMarkers: 0,           // "peut-√™tre", "parfois", etc.
                
                // Patterns linguistiques
                topWords: {},               // mot ‚Üí count
                connectors: {},             // donc, mais, car ‚Üí count
                
                // Coh√©rence √©motionnelle
                emotionalWords: {},         // mot √©motionnel ‚Üí count
                emotionalIntensity: [],     // 1-10 par message
                
                // M√©ta
                messagesAnalyzed: 0,
                totalCharacters: 0,
            },

            // Dictionnaires de r√©f√©rence
            dict: {
                exampleMarkers: ['par exemple', 'comme', 'notamment', 'tel que', 'ainsi', 'prenons'],
                reflectionMarkers: ['je pense', 'je crois', 'je ressens', 'je trouve', 'il me semble', '√† mon avis', "j'ai l'impression"],
                nuanceMarkers: ['peut-√™tre', 'parfois', 'souvent', 'g√©n√©ralement', 'plut√¥t', 'assez', 'relativement', 'probablement'],
                connectors: ['donc', 'mais', 'car', 'parce que', 'cependant', 'toutefois', 'n√©anmoins', 'ainsi', 'alors', 'puis'],
                emotionalWords: {
                    positive: ['heureux', 'content', 'joyeux', 'satisfait', 'motiv√©', 'enthousiaste', 'serein', 'calme', 'confiant', 'optimiste'],
                    negative: ['triste', 'anxieux', 'stress√©', 'inquiet', 'frustr√©', 'd√©√ßu', 'en col√®re', 'malheureux', 'd√©prim√©', 'pessimiste'],
                }
            },

            // D√©marrer la capture pour un nouveau message
            startCapture() {
                this.state.currentMessageStart = Date.now();
                console.log('Paraverbal: Capture started');
            },

            // Terminer la capture et enregistrer le temps
            endCapture() {
                if (this.state.currentMessageStart) {
                    const duration = (Date.now() - this.state.currentMessageStart) / 1000;
                    this.state.compositionTimes.push(duration);
                    this.state.currentMessageStart = null;
                    console.log(`Paraverbal: Message composed in ${duration.toFixed(1)}s`);
                }
            },

            // Analyser un message complet
            analyzeMessage(text) {
                if (!text || text.trim().length === 0) return;

                this.state.messagesAnalyzed++;
                const cleanText = text.toLowerCase();
                const words = text.match(/\b[\w√†√¢√§√©√®√™√´√Ø√Æ√¥√π√ª√º√ø√¶≈ì√ß]+\b/gi) || [];
                const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);

                // 1. EXPRESSIVIT√â
                this.analyzeExpressiveness(text, sentences);

                // 2. PROFONDEUR
                this.analyzeDepth(text, cleanText, words);

                // 3. PATTERNS LINGUISTIQUES
                this.analyzePatterns(cleanText, words);

                // 4. COH√âRENCE √âMOTIONNELLE
                this.analyzeEmotional(cleanText);

                console.log('Paraverbal: Message analyzed', {
                    words: words.length,
                    sentences: sentences.length,
                    messagesAnalyzed: this.state.messagesAnalyzed
                });
            },

            // Analyser l'expressivit√©
            analyzeExpressiveness(text, sentences) {
                // Ponctuation
                this.state.punctuation.exclamation += (text.match(/!/g) || []).length;
                this.state.punctuation.question += (text.match(/\?/g) || []).length;
                this.state.punctuation.ellipsis += (text.match(/\.{3,}/g) || []).length;

                // Mots en majuscules
                const capsWords = text.match(/\b[A-Z√Ä√Ç√Ñ√â√à√ä√ã√è√é√î√ô√õ√ú≈∏√Ü≈í√á]{3,}\b/g) || [];
                this.state.punctuation.allCapsWords += capsWords.length;

                // Longueur des phrases
                sentences.forEach(s => {
                    const words = s.trim().split(/\s+/).length;
                    this.state.sentenceLengths.push(words);
                });

                // Emojis
                const emojiRegex = /[\u{1F600}-\u{1F64F}\u{1F300}-\u{1F5FF}\u{1F680}-\u{1F6FF}\u{1F1E0}-\u{1F1FF}\u{2600}-\u{26FF}\u{2700}-\u{27BF}]/gu;
                const emojis = text.match(emojiRegex) || [];
                emojis.forEach(emoji => {
                    this.state.emojisUsed[emoji] = (this.state.emojisUsed[emoji] || 0) + 1;
                });
            },

            // Analyser la profondeur
            analyzeDepth(text, cleanText, words) {
                this.state.wordsPerMessage.push(words.length);
                this.state.totalCharacters += text.length;

                // Vocabulaire unique
                words.forEach(word => {
                    if (word.length > 3) {
                        this.state.vocabularyUnique.add(word.toLowerCase());
                    }
                });

                // Markers
                this.dict.exampleMarkers.forEach(marker => {
                    const count = (cleanText.match(new RegExp(marker, 'g')) || []).length;
                    this.state.exampleMarkers += count;
                });

                this.dict.reflectionMarkers.forEach(marker => {
                    const count = (cleanText.match(new RegExp(marker, 'g')) || []).length;
                    this.state.reflectionMarkers += count;
                });

                this.dict.nuanceMarkers.forEach(marker => {
                    const count = (cleanText.match(new RegExp(marker, 'g')) || []).length;
                    this.state.nuanceMarkers += count;
                });
            },

            // Analyser les patterns linguistiques
            analyzePatterns(cleanText, words) {
                // Top words
                words.forEach(word => {
                    const w = word.toLowerCase();
                    if (w.length > 3) {
                        this.state.topWords[w] = (this.state.topWords[w] || 0) + 1;
                    }
                });

                // Connecteurs
                this.dict.connectors.forEach(connector => {
                    const count = (cleanText.match(new RegExp(`\\b${connector}\\b`, 'g')) || []).length;
                    if (count > 0) {
                        this.state.connectors[connector] = (this.state.connectors[connector] || 0) + count;
                    }
                });
            },

            // Analyser la coh√©rence √©motionnelle
            analyzeEmotional(cleanText) {
                let emotionalScore = 5;

                this.dict.emotionalWords.positive.forEach(word => {
                    if (cleanText.includes(word)) {
                        this.state.emotionalWords[word] = (this.state.emotionalWords[word] || 0) + 1;
                        emotionalScore += 0.5;
                    }
                });

                this.dict.emotionalWords.negative.forEach(word => {
                    if (cleanText.includes(word)) {
                        this.state.emotionalWords[word] = (this.state.emotionalWords[word] || 0) + 1;
                        emotionalScore -= 0.5;
                    }
                });

                emotionalScore = Math.max(1, Math.min(10, emotionalScore));
                this.state.emotionalIntensity.push(emotionalScore);
            },

            // Obtenir les insights
            getInsights() {
                if (this.state.messagesAnalyzed < 3) return null;

                const insights = [];

                // Rythme
                if (this.state.compositionTimes.length > 0) {
                    const avgTime = this.state.compositionTimes.reduce((a, b) => a + b, 0) / this.state.compositionTimes.length;
                    if (avgTime > 60) {
                        insights.push("Tu prends ton temps pour composer tes r√©ponses - style r√©fl√©chi.");
                    } else if (avgTime < 20) {
                        insights.push("Tu r√©ponds rapidement - style spontan√©.");
                    }
                }

                // Expressivit√©
                const totalPunctuation = this.state.punctuation.exclamation + this.state.punctuation.question;
                if (totalPunctuation > this.state.messagesAnalyzed * 2) {
                    insights.push("Tu utilises beaucoup de ponctuation expressive - style dynamique.");
                }

                // Profondeur
                const avgWords = this.state.wordsPerMessage.reduce((a, b) => a + b, 0) / this.state.wordsPerMessage.length;
                if (avgWords > 80) {
                    insights.push("Tes r√©ponses sont d√©taill√©es et d√©velopp√©es.");
                } else if (avgWords < 30) {
                    insights.push("Tes r√©ponses sont concises et directes.");
                }

                // R√©flexion
                if (this.state.reflectionMarkers > this.state.messagesAnalyzed) {
                    insights.push("Tu utilises souvent des marqueurs de r√©flexion - style introspectif.");
                }

                // Nuances
                if (this.state.nuanceMarkers > this.state.messagesAnalyzed) {
                    insights.push("Tu nuances beaucoup tes propos - style prudent et mesur√©.");
                }

                return insights.length > 0 ? insights : null;
            },

            // G√©n√©rer le rapport complet
            getReport() {
                const avgCompositionTime = this.state.compositionTimes.length > 0
                    ? this.state.compositionTimes.reduce((a, b) => a + b, 0) / this.state.compositionTimes.length
                    : 0;

                const avgWordsPerMessage = this.state.wordsPerMessage.length > 0
                    ? this.state.wordsPerMessage.reduce((a, b) => a + b, 0) / this.state.wordsPerMessage.length
                    : 0;

                const avgSentenceLength = this.state.sentenceLengths.length > 0
                    ? this.state.sentenceLengths.reduce((a, b) => a + b, 0) / this.state.sentenceLengths.length
                    : 0;

                const avgEmotionalIntensity = this.state.emotionalIntensity.length > 0
                    ? this.state.emotionalIntensity.reduce((a, b) => a + b, 0) / this.state.emotionalIntensity.length
                    : 5;

                // Top 10 mots
                const topWordsArray = Object.entries(this.state.topWords)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 10)
                    .map(([word, count]) => ({ word, count }));

                // Style linguistique
                let linguisticStyle = 'neutral';
                if (this.state.reflectionMarkers > this.state.messagesAnalyzed) {
                    linguisticStyle = 'reflective';
                }
                if (this.state.nuanceMarkers > this.state.messagesAnalyzed) {
                    linguisticStyle += '_nuanced';
                }

                return {
                    rhythm: {
                        averageCompositionTime: parseFloat(avgCompositionTime.toFixed(1)),
                        totalMessages: this.state.compositionTimes.length,
                        pattern: avgCompositionTime > 60 ? 'thoughtful' : avgCompositionTime < 20 ? 'spontaneous' : 'balanced'
                    },
                    expressiveness: {
                        punctuation: { ...this.state.punctuation },
                        emojis: { ...this.state.emojisUsed },
                        averageSentenceLength: parseFloat(avgSentenceLength.toFixed(1)),
                        emphasisLevel: this.state.punctuation.exclamation > this.state.messagesAnalyzed ? 'high' : 'moderate'
                    },
                    depth: {
                        averageWordsPerMessage: parseFloat(avgWordsPerMessage.toFixed(1)),
                        uniqueVocabularySize: this.state.vocabularyUnique.size,
                        totalCharacters: this.state.totalCharacters,
                        exampleMarkers: this.state.exampleMarkers,
                        reflectionMarkers: this.state.reflectionMarkers,
                        nuanceMarkers: this.state.nuanceMarkers,
                        lexicalRichness: parseFloat((this.state.vocabularyUnique.size / Math.max(this.state.totalCharacters, 1) * 100).toFixed(2))
                    },
                    patterns: {
                        topWords: topWordsArray,
                        connectors: { ...this.state.connectors },
                        linguisticStyle: linguisticStyle
                    },
                    emotional: {
                        vocabulary: { ...this.state.emotionalWords },
                        averageIntensity: parseFloat(avgEmotionalIntensity.toFixed(1)),
                        coherence: this.state.emotionalIntensity.length > 2 ? 'analyzable' : 'insufficient_data'
                    },
                    meta: {
                        messagesAnalyzed: this.state.messagesAnalyzed
                    }
                };
            },

            // Mettre √† jour l'affichage dans l'interface
            updateDisplay() {
                if (this.state.messagesAnalyzed < 3) return;

                const report = this.getReport();

                // Rythme
                const rythmEl = document.getElementById('paraverbalRythm');
                if (rythmEl) {
                    const avgTime = report.rhythm.averageCompositionTime;
                    let rythmText = `${avgTime.toFixed(0)}s/msg`;
                    if (report.rhythm.pattern === 'thoughtful') rythmText += ' (r√©fl√©chi)';
                    else if (report.rhythm.pattern === 'spontaneous') rythmText += ' (spontan√©)';
                    rythmEl.textContent = rythmText;
                }

                // Expressivit√©
                const expEl = document.getElementById('paraverbalExpressiveness');
                if (expEl) {
                    const emphasisLevel = report.expressiveness.emphasisLevel;
                    const emojiCount = Object.keys(report.expressiveness.emojis).length;
                    let expText = emphasisLevel === 'high' ? '√âlev√©e' : 'Mod√©r√©e';
                    if (emojiCount > 0) expText += ` (${emojiCount} emojis)`;
                    expEl.textContent = expText;
                }

                // Profondeur
                const depthEl = document.getElementById('paraverbalDepth');
                if (depthEl) {
                    const avgWords = report.depth.averageWordsPerMessage;
                    const vocabSize = report.depth.uniqueVocabularySize;
                    depthEl.textContent = `${avgWords.toFixed(0)} mots (${vocabSize} uniques)`;
                }

                // Style
                const styleEl = document.getElementById('paraverbalStyle');
                if (styleEl) {
                    let styleText = '√âquilibr√©';
                    if (report.patterns.linguisticStyle.includes('reflective')) {
                        styleText = 'R√©flexif';
                    }
                    if (report.patterns.linguisticStyle.includes('nuanced')) {
                        styleText += ' & Nuanc√©';
                    }
                    styleEl.textContent = styleText;
                }
            }
        };

        // ============================================
        // MODULE 11: RAPPORT PSYCHOLOGIQUE PDF
        // ============================================
        const PsychologicalReport = {
            
            // G√©n√©rer le rapport complet
            async generate() {
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF();
                
                // Get all data
                const bigFive = {
                    initial: state.initialTraits,
                    final: state.finalTraits,
                    evolution: this.calculateEvolution()
                };
                const paraverbal = Paraverbal.getReport();
                const userName = localStorage.getItem('avatar_name') || 'Participant';
                
                // Configuration
                const margin = 20;
                const pageWidth = doc.internal.pageSize.width;
                const pageHeight = doc.internal.pageSize.height;
                const contentWidth = pageWidth - 2 * margin;
                let y = margin;
                
                // Colors Institut du Couple
                const primaryColor = [143, 175, 177];  // Mer
                const textColor = [51, 51, 51];
                
                // Helper functions
                const addPage = () => {
                    doc.addPage();
                    y = margin;
                };
                
                const checkPageBreak = (neededSpace) => {
                    if (y + neededSpace > pageHeight - margin) {
                        addPage();
                    }
                };
                
                const addTitle = (text, size = 16, color = primaryColor) => {
                    checkPageBreak(15);
                    doc.setFontSize(size);
                    doc.setTextColor(...color);
                    doc.setFont('helvetica', 'bold');
                    doc.text(text, margin, y);
                    y += 10;
                };
                
                const addSubtitle = (text) => {
                    checkPageBreak(12);
                    doc.setFontSize(12);
                    doc.setTextColor(...primaryColor);
                    doc.setFont('helvetica', 'bold');
                    doc.text(text, margin, y);
                    y += 8;
                };
                
                const addText = (text, indent = 0) => {
                    doc.setFontSize(10);
                    doc.setTextColor(...textColor);
                    doc.setFont('helvetica', 'normal');
                    const lines = doc.splitTextToSize(text, contentWidth - indent);
                    lines.forEach(line => {
                        checkPageBreak(7);
                        doc.text(line, margin + indent, y);
                        y += 7;
                    });
                };
                
                const addSeparator = () => {
                    checkPageBreak(5);
                    doc.setDrawColor(...primaryColor);
                    doc.line(margin, y, pageWidth - margin, y);
                    y += 10;
                };
                
                // ========================================
                // PAGE 1: PAGE DE GARDE
                // ========================================
                doc.setFillColor(...primaryColor);
                doc.rect(0, 0, pageWidth, 60, 'F');
                
                doc.setTextColor(255, 255, 255);
                doc.setFontSize(24);
                doc.setFont('helvetica', 'bold');
                doc.text('RAPPORT PSYCHOLOGIQUE', pageWidth / 2, 30, { align: 'center' });
                
                doc.setFontSize(14);
                doc.setFont('helvetica', 'normal');
                doc.text('Analyse Multi-Dimensionnelle de Personnalit√©', pageWidth / 2, 45, { align: 'center' });
                
                y = 80;
                doc.setTextColor(...textColor);
                doc.setFontSize(12);
                doc.text(`Participant : ${userName}`, margin, y);
                y += 10;
                doc.text(`Date : ${new Date().toLocaleDateString('fr-FR')}`, margin, y);
                y += 10;
                doc.text(`Dur√©e interview : ${Math.floor(state.elapsedSeconds / 60)} minutes`, margin, y);
                y += 10;
                doc.text(`Nombre de r√©ponses : ${state.responseCount}`, margin, y);
                
                y = 140;
                doc.setFontSize(10);
                doc.setFont('helvetica', 'italic');
                doc.text('Institut du Couple', pageWidth / 2, y, { align: 'center' });
                y += 7;
                doc.text('Analyse confidentielle - Usage th√©rapeutique uniquement', pageWidth / 2, y, { align: 'center' });
                
                // Footer
                doc.setFontSize(8);
                doc.text('Clone de Personnalit√© v8.0 ULTIMATE', pageWidth / 2, pageHeight - 10, { align: 'center' });
                
                // ========================================
                // PAGE 2: SYNTH√àSE EX√âCUTIVE
                // ========================================
                addPage();
                addTitle('1. SYNTH√àSE EX√âCUTIVE');
                addSeparator();
                
                const profile = this.generateExecutiveSummary(bigFive, paraverbal);
                addText(profile.overview);
                y += 5;
                
                addSubtitle('Profil dominant');
                addText(profile.dominantProfile, 5);
                y += 5;
                
                addSubtitle('Traits caract√©ristiques');
                profile.keyTraits.forEach(trait => {
                    addText(`‚Ä¢ ${trait}`, 5);
                });
                
                // ========================================
                // PAGE 3-4: ANALYSE BIG FIVE
                // ========================================
                addPage();
                addTitle('2. ANALYSE BIG FIVE APPROFONDIE');
                addSeparator();
                
                const traits = [
                    { name: 'Ouverture', key: 'openness', score: bigFive.final.openness },
                    { name: 'Conscience', key: 'conscientiousness', score: bigFive.final.conscientiousness },
                    { name: 'Extraversion', key: 'extraversion', score: bigFive.final.extraversion },
                    { name: 'Agr√©abilit√©', key: 'agreeableness', score: bigFive.final.agreeableness },
                    { name: 'Stabilit√© √âmotionnelle', key: 'emotionalStability', score: bigFive.final.emotionalStability }
                ];
                
                traits.forEach(trait => {
                    const analysis = this.analyzeTrait(trait.name, trait.score, trait.key);
                    
                    addSubtitle(`${trait.name} : ${trait.score.toFixed(1)}/10`);
                    
                    // Barre visuelle
                    const barWidth = (contentWidth - 20) * (trait.score / 10);
                    doc.setFillColor(...primaryColor);
                    doc.rect(margin + 5, y, barWidth, 5, 'F');
                    doc.setDrawColor(200, 200, 200);
                    doc.rect(margin + 5, y, contentWidth - 20, 5);
                    y += 10;
                    
                    addText(analysis.interpretation, 5);
                    y += 3;
                    addText(`Manifestations : ${analysis.manifestations}`, 5);
                    y += 3;
                    addText(`Impact relationnel : ${analysis.relationalImpact}`, 5);
                    y += 8;
                });
                
                // ========================================
                // PAGE 5: PROFIL PARAVERBAL
                // ========================================
                addPage();
                addTitle('3. ANALYSE PARAVERBALE');
                addSeparator();
                
                const paraAnalysis = this.analyzeParaverbal(paraverbal);
                
                addSubtitle('Style communicationnel');
                addText(paraAnalysis.style, 5);
                y += 5;
                
                addSubtitle('Rythme et expressivit√©');
                addText(paraAnalysis.rhythm, 5);
                y += 5;
                
                addSubtitle('Patterns linguistiques');
                addText(paraAnalysis.patterns, 5);
                y += 5;
                
                addSubtitle('Implications relationnelles');
                addText(paraAnalysis.relational, 5);
                
                // ========================================
                // PAGE 6: DYNAMIQUE √âMOTIONNELLE
                // ========================================
                addPage();
                addTitle('4. DYNAMIQUE √âMOTIONNELLE');
                addSeparator();
                
                const emotionalAnalysis = this.analyzeEmotional(paraverbal);
                
                addSubtitle('Vocabulaire √©motionnel');
                addText(emotionalAnalysis.vocabulary, 5);
                y += 5;
                
                addSubtitle('Intensit√© et r√©gulation');
                addText(emotionalAnalysis.intensity, 5);
                y += 5;
                
                addSubtitle('Coh√©rence affective');
                addText(emotionalAnalysis.coherence, 5);
                
                // ========================================
                // PAGE 7: STRUCTURE COGNITIVE
                // ========================================
                addPage();
                addTitle('5. STRUCTURE COGNITIVE');
                addSeparator();
                
                const cognitiveAnalysis = this.analyzeCognitive(paraverbal);
                
                addSubtitle('Profondeur r√©flexive');
                addText(cognitiveAnalysis.depth, 5);
                y += 5;
                
                addSubtitle('Complexit√© de pens√©e');
                addText(cognitiveAnalysis.complexity, 5);
                y += 5;
                
                addSubtitle('Capacit√© d\'introspection');
                addText(cognitiveAnalysis.introspection, 5);
                
                // ========================================
                // PAGE 8-9: PROFIL RELATIONNEL
                // ========================================
                addPage();
                addTitle('6. PROFIL RELATIONNEL');
                addSeparator();
                
                const relationalAnalysis = this.analyzeRelational(bigFive, paraverbal);
                
                addSubtitle('Style de communication en couple');
                addText(relationalAnalysis.communicationStyle, 5);
                y += 5;
                
                addSubtitle('Besoins relationnels');
                relationalAnalysis.needs.forEach(need => {
                    addText(`‚Ä¢ ${need}`, 5);
                });
                y += 5;
                
                addSubtitle('Zones de vuln√©rabilit√©');
                relationalAnalysis.vulnerabilities.forEach(vuln => {
                    addText(`‚Ä¢ ${vuln}`, 5);
                });
                y += 5;
                
                addSubtitle('Ressources et points forts');
                relationalAnalysis.strengths.forEach(strength => {
                    addText(`‚Ä¢ ${strength}`, 5);
                });
                
                // ========================================
                // PAGE 10: RECOMMANDATIONS
                // ========================================
                addPage();
                addTitle('7. RECOMMANDATIONS TH√âRAPEUTIQUES');
                addSeparator();
                
                const recommendations = this.generateRecommendations(bigFive, paraverbal);
                
                addSubtitle('Axes de travail personnel');
                recommendations.personal.forEach(rec => {
                    addText(`‚Ä¢ ${rec}`, 5);
                });
                y += 5;
                
                addSubtitle('Pistes th√©rapie de couple');
                recommendations.couple.forEach(rec => {
                    addText(`‚Ä¢ ${rec}`, 5);
                });
                y += 5;
                
                addSubtitle('Exercices sugg√©r√©s');
                recommendations.exercises.forEach(ex => {
                    addText(`‚Ä¢ ${ex}`, 5);
                });
                
                // ========================================
                // PAGE 11: √âVOLUTION
                // ========================================
                addPage();
                addTitle('8. √âVOLUTION PENDANT L\'INTERVIEW');
                addSeparator();
                
                if (bigFive.evolution) {
                    addText('L\'analyse de l\'√©volution des traits pendant l\'interview r√©v√®le les changements suivants :');
                    y += 5;
                    
                    Object.entries(bigFive.evolution).forEach(([trait, change]) => {
                        const changeName = {
                            openness: 'Ouverture',
                            conscientiousness: 'Conscience',
                            extraversion: 'Extraversion',
                            agreeableness: 'Agr√©abilit√©',
                            emotionalStability: 'Stabilit√© √âmotionnelle'
                        }[trait];
                        
                        const interpretation = parseFloat(change) > 0 ? 'augmentation' : 'diminution';
                        addText(`‚Ä¢ ${changeName} : ${change} point(s) - ${interpretation}`, 5);
                    });
                    
                    y += 10;
                    const totalEvolution = Object.values(bigFive.evolution)
                        .reduce((sum, val) => sum + Math.abs(parseFloat(val)), 0);
                    
                    let evolutionText = '';
                    if (totalEvolution < 1) {
                        evolutionText = 'Le profil s\'est r√©v√©l√© tr√®s coh√©rent, avec peu de variations. Cela sugg√®re une bonne connaissance de soi pr√©alable.';
                    } else if (totalEvolution < 3) {
                        evolutionText = 'L\'interview a permis un raffinement progressif du profil, typique d\'un processus de d√©couverte de soi.';
                    } else {
                        evolutionText = 'L\'interview a r√©v√©l√© des changements significatifs, sugg√©rant de nouvelles prises de conscience importantes.';
                    }
                    
                    addText(evolutionText, 5);
                }
                
                // Footer derni√®re page
                y = pageHeight - 30;
                doc.setFontSize(9);
                doc.setFont('helvetica', 'italic');
                doc.text('Ce rapport est confidentiel et destin√© uniquement √† un usage th√©rapeutique.', pageWidth / 2, y, { align: 'center' });
                y += 7;
                doc.text('Institut du Couple - Analyse psychologique professionnelle', pageWidth / 2, y, { align: 'center' });
                
                // Save PDF
                doc.save(`Rapport-Psychologique-${userName.replace(/\s+/g, '-')}.pdf`);
                Utils.showToast('Rapport psychologique g√©n√©r√© !', 'success');
            },
            
            // Calculate trait evolution
            calculateEvolution() {
                if (!state.initialTraits || !state.finalTraits) return null;
                
                return {
                    openness: (state.finalTraits.openness - state.initialTraits.openness).toFixed(1),
                    conscientiousness: (state.finalTraits.conscientiousness - state.initialTraits.conscientiousness).toFixed(1),
                    extraversion: (state.finalTraits.extraversion - state.initialTraits.extraversion).toFixed(1),
                    agreeableness: (state.finalTraits.agreeableness - state.initialTraits.agreeableness).toFixed(1),
                    emotionalStability: (state.finalTraits.emotionalStability - state.initialTraits.emotionalStability).toFixed(1),
                };
            },
            
            // Generate executive summary
            generateExecutiveSummary(bigFive, paraverbal) {
                const traits = bigFive.final;
                const avgScore = (traits.openness + traits.conscientiousness + traits.extraversion + 
                                 traits.agreeableness + traits.emotionalStability) / 5;
                
                // Determine dominant traits
                const traitNames = {
                    openness: 'Ouverture',
                    conscientiousness: 'Conscience',
                    extraversion: 'Extraversion',
                    agreeableness: 'Agr√©abilit√©',
                    emotionalStability: 'Stabilit√© √âmotionnelle'
                };
                
                const sortedTraits = Object.entries(traits)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 3);
                
                // Generate overview
                let overview = `L'analyse r√©v√®le un profil de personnalit√© √©quilibr√© avec un score moyen de ${avgScore.toFixed(1)}/10. `;
                
                if (paraverbal.rhythm.pattern === 'thoughtful') {
                    overview += 'Le rythme de composition r√©fl√©chi sugg√®re une personnalit√© introspective qui prend le temps d\'analyser avant de s\'exprimer. ';
                } else if (paraverbal.rhythm.pattern === 'spontaneous') {
                    overview += 'Le rythme de composition spontan√© sugg√®re une personnalit√© r√©active et directe dans son expression. ';
                }
                
                if (paraverbal.depth.averageWordsPerMessage > 80) {
                    overview += 'La richesse des r√©ponses indique une capacit√© d√©velopp√©e d\'√©laboration et de nuance.';
                }
                
                // Dominant profile
                let dominantProfile = 'Profil ';
                if (traits.openness > 7 && paraverbal.patterns.linguisticStyle.includes('reflective')) {
                    dominantProfile += 'introspectif cr√©atif - ';
                } else if (traits.conscientiousness > 7) {
                    dominantProfile += 'structur√© et consciencieux - ';
                } else if (traits.extraversion > 7) {
                    dominantProfile += 'extraverti et sociable - ';
                }
                dominantProfile += `caract√©ris√© par des niveaux √©lev√©s de ${traitNames[sortedTraits[0][0]]} et ${traitNames[sortedTraits[1][0]]}.`;
                
                // Key traits
                const keyTraits = [
                    `${traitNames[sortedTraits[0][0]]} √©lev√©e (${sortedTraits[0][1].toFixed(1)}/10)`,
                    `${traitNames[sortedTraits[1][0]]} marqu√©e (${sortedTraits[1][1].toFixed(1)}/10)`,
                    `Style communicationnel ${paraverbal.rhythm.pattern === 'thoughtful' ? 'r√©fl√©chi' : 'spontan√©'}`,
                    `Expressivit√© ${paraverbal.expressiveness.emphasisLevel}`
                ];
                
                return { overview, dominantProfile, keyTraits };
            },
            
            // Analyze individual trait
            analyzeTrait(name, score, key) {
                const interpretations = {
                    openness: {
                        high: 'Score √©lev√© indiquant une forte curiosit√© intellectuelle, une appr√©ciation de l\'art et de la beaut√©, et une ouverture aux exp√©riences nouvelles.',
                        medium: 'Score mod√©r√© sugg√©rant un √©quilibre entre ouverture aux nouveaut√©s et attachement aux traditions.',
                        low: 'Score indiquant une pr√©f√©rence pour le familier et le conventionnel, avec une approche pragmatique.'
                    },
                    conscientiousness: {
                        high: 'Score √©lev√© r√©v√©lant une personnalit√© organis√©e, disciplin√©e, avec un sens aigu du devoir et de la responsabilit√©.',
                        medium: 'Score mod√©r√© indiquant une capacit√© d\'organisation variable selon les contextes et les priorit√©s.',
                        low: 'Score sugg√©rant une approche plus flexible et spontan√©e, parfois au d√©triment de la planification.'
                    },
                    extraversion: {
                        high: 'Score √©lev√© caract√©ristique d\'une personnalit√© sociable, √©nergique, qui puise son √©nergie dans les interactions sociales.',
                        medium: 'Score mod√©r√© sugg√©rant une ambiversion - capacit√© √† √™tre sociable tout en appr√©ciant les moments de solitude.',
                        low: 'Score indiquant une pr√©f√©rence pour les interactions en petit comit√© et les activit√©s introspectives.'
                    },
                    agreeableness: {
                        high: 'Score √©lev√© r√©v√©lant une personnalit√© chaleureuse, empathique, avec une forte orientation vers l\'harmonie relationnelle.',
                        medium: 'Score mod√©r√© indiquant un √©quilibre entre bienveillance et affirmation de soi.',
                        low: 'Score sugg√©rant une approche plus directe et critique, privil√©giant l\'authenticit√© sur l\'harmonie.'
                    },
                    emotionalStability: {
                        high: 'Score √©lev√© indiquant une bonne r√©gulation √©motionnelle et une r√©silience face au stress.',
                        medium: 'Score mod√©r√© sugg√©rant une sensibilit√© √©motionnelle normale avec des capacit√©s variables de r√©gulation.',
                        low: 'Score r√©v√©lant une sensibilit√© √©motionnelle accrue et une r√©activit√© plus importante aux stress.'
                    }
                };
                
                const manifestations = {
                    openness: score > 7 ? 'Recherche active de nouvelles exp√©riences, cr√©ativit√©, pens√©e abstraite' : 
                              score > 4 ? 'Ouverture s√©lective, cr√©ativit√© contextuelle' : 
                              'Pr√©f√©rence pour la routine, pens√©e concr√®te',
                    conscientiousness: score > 7 ? 'Organisation m√©ticuleuse, respect strict des engagements, planification d√©taill√©e' :
                                      score > 4 ? 'Organisation adaptative, engagement variable' :
                                      'Approche flexible, spontan√©it√©',
                    extraversion: score > 7 ? 'Recherche active d\'interactions, √©nergie sociale √©lev√©e' :
                                 score > 4 ? 'Sociabilit√© s√©lective, √©nergie mod√©r√©e' :
                                 'Pr√©f√©rence pour la solitude, interactions limit√©es',
                    agreeableness: score > 7 ? 'Forte empathie, comportement altruiste, √©vitement des conflits' :
                                  score > 4 ? 'Empathie s√©lective, assertivit√© mod√©r√©e' :
                                  'Approche directe, critique constructive',
                    emotionalStability: score > 7 ? 'Calme sous pression, optimisme, faible r√©activit√© √©motionnelle' :
                                       score > 4 ? 'R√©activit√© √©motionnelle variable, r√©gulation contextuelle' :
                                       'Sensibilit√© accrue, r√©activit√© √©motionnelle importante'
                };
                
                const relationalImpacts = {
                    openness: score > 7 ? 'Apporte nouveaut√© et stimulation dans le couple, encourage l\'exploration commune' :
                              score > 4 ? '√âquilibre entre stabilit√© et nouveaut√© dans la relation' :
                              'Apporte stabilit√© et pr√©visibilit√©, peut r√©sister aux changements',
                    conscientiousness: score > 7 ? 'Fiabilit√© et organisation du couple, peut √™tre per√ßu comme rigide' :
                                      score > 4 ? 'Organisation flexible du quotidien conjugal' :
                                      'Spontan√©it√©, peut cr√©er des tensions sur l\'organisation',
                    extraversion: score > 7 ? 'Dynamisme social du couple, besoin d\'interactions fr√©quentes' :
                                 score > 4 ? '√âquilibre entre vie sociale et intimit√© √† deux' :
                                 'Pr√©f√©rence pour l\'intimit√© √† deux, vie sociale limit√©e',
                    agreeableness: score > 7 ? 'Harmonie relationnelle, r√©solution coop√©rative des conflits, risque d\'√©vitement' :
                                  score > 4 ? 'Communication √©quilibr√©e, gestion constructive des d√©saccords' :
                                  'Communication directe, peut g√©n√©rer des tensions mais favorise l\'authenticit√©',
                    emotionalStability: score > 7 ? 'Stabilit√© √©motionnelle du couple, soutien dans les crises' :
                                       score > 4 ? 'R√©activit√© √©motionnelle normale, besoin de soutien variable' :
                                       'Sensibilit√© √©motionnelle √©lev√©e, besoin important de soutien et r√©assurance'
                };
                
                const level = score > 7 ? 'high' : score > 4 ? 'medium' : 'low';
                
                return {
                    interpretation: interpretations[key][level],
                    manifestations: manifestations[key],
                    relationalImpact: relationalImpacts[key]
                };
            },
            
            // Analyze paraverbal
            analyzeParaverbal(paraverbal) {
                let style = '';
                if (paraverbal.rhythm.pattern === 'thoughtful') {
                    style = 'Le style communicationnel se caract√©rise par une approche r√©fl√©chie et pos√©e. Les r√©ponses sont construites avec soin, sugg√©rant un besoin de clart√© et de pr√©cision dans l\'expression. ';
                } else if (paraverbal.rhythm.pattern === 'spontaneous') {
                    style = 'Le style communicationnel se caract√©rise par une spontan√©it√© et une r√©activit√©. Les r√©ponses sont rapides et directes, r√©v√©lant une pens√©e fluide et une aisance d\'expression. ';
                }
                
                if (paraverbal.patterns.linguisticStyle.includes('reflective')) {
                    style += 'La pr√©sence fr√©quente de marqueurs de r√©flexion ("je pense", "il me semble") indique une personnalit√© introspective qui relativise ses propres perspectives.';
                }
                
                let rhythm = `Le temps de composition moyen de ${paraverbal.rhythm.averageCompositionTime.toFixed(0)} secondes par message r√©v√®le un rythme ${paraverbal.rhythm.pattern === 'thoughtful' ? 'r√©fl√©chi' : 'spontan√©'}. `;
                
                if (paraverbal.expressiveness.emphasisLevel === 'high') {
                    rhythm += 'L\'expressivit√© est marqu√©e avec une utilisation fr√©quente de ponctuation expressive (!, ?, ...), sugg√©rant une communication √©nergique et √©motionnellement investie.';
                } else {
                    rhythm += 'L\'expressivit√© est mesur√©e, avec une ponctuation sobre qui refl√®te un style de communication plus r√©serv√©.';
                }
                
                let patterns = `L'analyse linguistique r√©v√®le un vocabulaire de ${paraverbal.depth.uniqueVocabularySize} mots uniques, indiquant une richesse lexicale ${paraverbal.depth.uniqueVocabularySize > 300 ? 'importante' : 'mod√©r√©e'}. `;
                
                if (paraverbal.depth.nuanceMarkers > 10) {
                    patterns += 'La pr√©sence fr√©quente de nuances ("peut-√™tre", "parfois", "souvent") r√©v√®le une pens√©e complexe qui √©vite les absolus.';
                }
                
                let relational = 'Dans le contexte relationnel, ';
                if (paraverbal.rhythm.pattern === 'thoughtful' && paraverbal.depth.averageWordsPerMessage > 80) {
                    relational += 'ce style favorise des √©changes profonds et √©labor√©s, propices √† l\'exploration √©motionnelle. Le partenaire peut appr√©cier cette profondeur tout en n√©cessitant parfois des √©changes plus concis.';
                } else if (paraverbal.rhythm.pattern === 'spontaneous') {
                    relational += 'ce style favorise des √©changes fluides et dynamiques. La spontan√©it√© peut √™tre appr√©ci√©e mais n√©cessite de s\'assurer que tous les sujets sont pleinement explor√©s.';
                }
                
                return { style, rhythm, patterns, relational };
            },
            
            // Analyze emotional
            analyzeEmotional(paraverbal) {
                const vocabSize = Object.keys(paraverbal.emotional.vocabulary).length;
                
                let vocabulary = `Le vocabulaire √©motionnel comprend ${vocabSize} termes diff√©rents, `;
                if (vocabSize > 10) {
                    vocabulary += 'r√©v√©lant une capacit√© d√©velopp√©e d\'identification et de diff√©renciation √©motionnelle. Cette granularit√© √©motionnelle est un atout pr√©cieux pour la r√©gulation √©motionnelle et la communication relationnelle.';
                } else if (vocabSize > 5) {
                    vocabulary += 'sugg√©rant une conscience √©motionnelle adapt√©e. Le d√©veloppement de ce vocabulaire pourrait enrichir l\'expression des nuances affectives.';
                } else {
                    vocabulary += 'indiquant un vocabulaire √©motionnel limit√©. L\'enrichissement de ce r√©pertoire faciliterait l\'expression et la r√©gulation des √©motions.';
                }
                
                const avgIntensity = paraverbal.emotional.averageIntensity;
                let intensity = `L'intensit√© √©motionnelle moyenne de ${avgIntensity.toFixed(1)}/10 `;
                if (avgIntensity > 7) {
                    intensity += 'r√©v√®le une vie √©motionnelle riche et intense. Cette sensibilit√© constitue une ressource pour l\'empathie et la connexion, tout en n√©cessitant des strat√©gies de r√©gulation pour √©viter la submersion √©motionnelle.';
                } else if (avgIntensity > 4) {
                    intensity += 'indique un √©quilibre √©motionnel sain, avec une capacit√© √† ressentir sans √™tre submerg√©. Cette r√©gulation naturelle favorise des relations stables.';
                } else {
                    intensity += 'sugg√®re une tendance √† la mod√©ration √©motionnelle. Selon le contexte, cela peut refl√©ter une bonne r√©gulation ou une forme de restriction √©motionnelle √† explorer.';
                }
                
                let coherence = 'L\'analyse de coh√©rence affective ';
                if (paraverbal.emotional.coherence === 'analyzable') {
                    coherence += 'r√©v√®le une expression √©motionnelle coh√©rente et authentique. Les variations d\'intensit√© semblent correspondre aux contenus abord√©s, sugg√©rant une bonne connexion entre ressenti et expression.';
                } else {
                    coherence += 'n√©cessite davantage de donn√©es pour une √©valuation fiable. Les premi√®res observations sugg√®rent une expression √©motionnelle en cours de d√©ploiement.';
                }
                
                return { vocabulary, intensity, coherence };
            },
            
            // Analyze cognitive
            analyzeCognitive(paraverbal) {
                let depth = '';
                if (paraverbal.depth.averageWordsPerMessage > 80) {
                    depth = 'La profondeur r√©flexive est remarquable, avec des r√©ponses d√©velopp√©es et √©labor√©es. Cette capacit√© d\'exploration approfondie r√©v√®le un besoin de comprendre en profondeur et une aisance avec la complexit√©.';
                } else if (paraverbal.depth.averageWordsPerMessage > 40) {
                    depth = 'La profondeur r√©flexive est √©quilibr√©e, avec des r√©ponses suffisamment d√©velopp√©es sans √™tre exhaustives. Cette approche pragmatique privil√©gie l\'efficacit√© communicationnelle.';
                } else {
                    depth = 'Le style de r√©flexion privil√©gie la concision et la synth√®se. Les r√©ponses vont √† l\'essentiel, r√©v√©lant une pr√©f√©rence pour l\'efficacit√© et la clart√©.';
                }
                
                let complexity = '';
                if (paraverbal.depth.nuanceMarkers > 15) {
                    complexity = 'La complexit√© de pens√©e est √©lev√©e, caract√©ris√©e par de nombreuses nuances et qualifications. Cette pens√©e non-dichotomique permet d\'appr√©hender les situations dans leur richesse et leurs paradoxes. ';
                    if (paraverbal.depth.reflectionMarkers > 15) {
                        complexity += 'La pr√©sence fr√©quente de marqueurs de r√©flexion renforce cette approche contemplative.';
                    }
                } else {
                    complexity = 'La pens√©e se caract√©rise par une clart√© et une d√©finition des positions. Cette approche directe facilite la prise de d√©cision et l\'action.';
                }
                
                let introspection = '';
                if (paraverbal.depth.reflectionMarkers > 20) {
                    introspection = 'La capacit√© d\'introspection est tr√®s d√©velopp√©e. Cette aptitude √† s\'observer et √† questionner ses propres processus est pr√©cieuse pour la croissance personnelle et la th√©rapie.';
                } else if (paraverbal.depth.reflectionMarkers > 10) {
                    introspection = 'La capacit√© d\'introspection est pr√©sente et fonctionnelle. Cette conscience de soi offre une base solide pour le travail th√©rapeutique.';
                } else {
                    introspection = 'Le style cognitif privil√©gie l\'action et l\'exp√©rience directe sur la r√©flexion introspective. Le d√©veloppement de cette dimension pourrait enrichir la conscience de soi.';
                }
                
                return { depth, complexity, introspection };
            },
            
            // Analyze relational
            analyzeRelational(bigFive, paraverbal) {
                const traits = bigFive.final;
                
                let communicationStyle = '';
                if (traits.agreeableness > 7 && paraverbal.rhythm.pattern === 'thoughtful') {
                    communicationStyle = 'Le style de communication en couple se caract√©rise par une attention bienveillante et r√©fl√©chie. La priorit√© donn√©e √† l\'harmonie et la prise de temps pour √©laborer favorisent une √©coute profonde et une expression soign√©e.';
                } else if (traits.agreeableness > 7 && paraverbal.rhythm.pattern === 'spontaneous') {
                    communicationStyle = 'Le style de communication allie chaleur relationnelle et spontan√©it√©. Cette combinaison cr√©e des √©changes fluides et authentiques, m√™me si une attention particuli√®re doit √™tre port√©e √† laisser l\'espace d\'expression au partenaire.';
                } else if (traits.extraversion > 7) {
                    communicationStyle = 'Le style de communication est dynamique et expressif. L\'√©nergie relationnelle est √©lev√©e, favorisant des √©changes vivants qui peuvent n√©cessiter des moments de pause pour approfondir.';
                } else {
                    communicationStyle = 'Le style de communication privil√©gie l\'authenticit√© et la profondeur sur la quantit√© d\'√©changes. Les moments de communication sont s√©lectionn√©s et investis avec intention.';
                }
                
                const needs = [];
                if (traits.emotionalStability < 6) {
                    needs.push('Besoin de r√©assurance et de soutien √©motionnel r√©gulier');
                }
                if (traits.openness > 7) {
                    needs.push('Besoin de nouveaut√© et d\'exploration commune');
                }
                if (traits.conscientiousness > 7) {
                    needs.push('Besoin de pr√©visibilit√© et d\'organisation partag√©e');
                }
                if (traits.extraversion > 7) {
                    needs.push('Besoin d\'interactions sociales et de vie sociale active');
                } else if (traits.extraversion < 4) {
                    needs.push('Besoin de temps d\'intimit√© √† deux et de respect des moments de solitude');
                }
                if (traits.agreeableness > 7) {
                    needs.push('Besoin d\'harmonie et d\'√©vitement des conflits prolong√©s');
                }
                
                const vulnerabilities = [];
                if (traits.agreeableness > 8) {
                    vulnerabilities.push('Risque d\'√©vitement des conflits n√©cessaires et d\'accumulation des non-dits');
                }
                if (traits.conscientiousness > 8) {
                    vulnerabilities.push('Risque de rigidit√© et de difficult√© face aux impr√©vus');
                }
                if (traits.emotionalStability < 5) {
                    vulnerabilities.push('Sensibilit√© aux critiques et aux tensions relationnelles');
                }
                if (traits.openness < 4) {
                    vulnerabilities.push('R√©sistance au changement et difficult√© avec les transitions');
                }
                if (paraverbal.depth.averageWordsPerMessage > 100) {
                    vulnerabilities.push('Risque de sur-explication et de difficult√© √† synth√©tiser dans l\'urgence');
                }
                
                const strengths = [];
                if (traits.agreeableness > 6) {
                    strengths.push('Empathie et capacit√© √† se mettre √† la place du partenaire');
                }
                if (traits.conscientiousness > 6) {
                    strengths.push('Fiabilit√© et respect des engagements');
                }
                if (traits.openness > 6) {
                    strengths.push('Ouverture au changement et capacit√© d\'adaptation');
                }
                if (traits.emotionalStability > 6) {
                    strengths.push('Stabilit√© √©motionnelle et capacit√© √† apaiser');
                }
                if (paraverbal.depth.reflectionMarkers > 15) {
                    strengths.push('Capacit√© d\'introspection et de remise en question');
                }
                if (paraverbal.depth.nuanceMarkers > 15) {
                    strengths.push('Pens√©e nuanc√©e facilitant la r√©solution de conflits complexes');
                }
                
                return { communicationStyle, needs, vulnerabilities, strengths };
            },
            
            // Generate recommendations
            generateRecommendations(bigFive, paraverbal) {
                const traits = bigFive.final;
                const personal = [];
                const couple = [];
                const exercises = [];
                
                // Personal recommendations
                if (traits.emotionalStability < 6) {
                    personal.push('D√©velopper des strat√©gies de r√©gulation √©motionnelle (respiration, pleine conscience)');
                    exercises.push('Pratique quotidienne de 10 minutes de m√©ditation de pleine conscience');
                }
                
                if (traits.openness > 8) {
                    personal.push('√âquilibrer le besoin de nouveaut√© avec la stabilit√© n√©cessaire √† une relation durable');
                }
                
                if (paraverbal.depth.reflectionMarkers > 20 && paraverbal.rhythm.averageCompositionTime > 60) {
                    personal.push('D√©velopper la capacit√© de d√©cision rapide dans les situations n√©cessitant de l\'action');
                    exercises.push('Exercice de d√©cision en temps limit√© (1 minute) sur des choix quotidiens');
                }
                
                if (traits.agreeableness > 8) {
                    personal.push('Travailler sur l\'affirmation de soi et l\'expression des besoins personnels');
                    exercises.push('Journal des besoins : noter quotidiennement un besoin non exprim√© et explorer comment le communiquer');
                }
                
                // Couple recommendations
                if (traits.conscientiousness > 7) {
                    couple.push('Explorer l\'impact du besoin de contr√¥le sur la dynamique relationnelle');
                    couple.push('Pratiquer la flexibilit√© en acceptant les impr√©vus comme opportunit√©s');
                }
                
                if (traits.extraversion > 7 || traits.extraversion < 4) {
                    couple.push('N√©gocier un √©quilibre entre vie sociale et intimit√© √† deux respectant les besoins de chacun');
                    exercises.push('Planifier alternativement des activit√©s sociales et des moments d\'intimit√©');
                }
                
                if (paraverbal.emotional.averageIntensity > 7) {
                    couple.push('√âtablir des rituels de connexion √©motionnelle r√©guliers');
                    exercises.push('Partage √©motionnel quotidien de 10 minutes : chacun exprime son √©tat √©motionnel sans jugement');
                }
                
                couple.push('Pratiquer l\'√©coute active avec reformulation pour assurer la compr√©hension mutuelle');
                exercises.push('Exercice de l\'√©coute : un partenaire s\'exprime 5 minutes, l\'autre reformule avant de r√©pondre');
                
                if (paraverbal.depth.nuanceMarkers > 15) {
                    couple.push('Valoriser la capacit√© de nuance dans la r√©solution de conflits complexes');
                }
                
                return { personal, couple, exercises };
            }
        };

        // ============================================
        // MODULE 12: SYST√àME CONCORDANCE √âVOLUTIF
        // ============================================
        const ConcordanceSystem = {
            
            metrics: {
                traitsMatch: 0,
                paraverbalMatch: 0,
                behavioralMatch: 0,
                emotionalMatch: 0,
                contextualMatch: 0,
                overall: 0,
                history: [],
                lastCalculated: null
            },
            
            config: {
                weights: {
                    traits: 0.25,
                    paraverbal: 0.20,
                    behavioral: 0.25,
                    emotional: 0.15,
                    contextual: 0.15
                },
                thresholds: {
                    minimal: 75,
                    optimal: 85,
                    worldClass: 90
                }
            },
            
            // Calculer concordance globale
            async calculateConcordance() {
                console.log('üéØ Calculating concordance...');
                
                const scores = {
                    traits: await this.measureTraits(),
                    paraverbal: await this.measureParaverbal(),
                    behavioral: await this.measureBehavioral(),
                    emotional: await this.measureEmotional(),
                    contextual: await this.measureContextual()
                };
                
                const overall = (
                    scores.traits * this.config.weights.traits +
                    scores.paraverbal * this.config.weights.paraverbal +
                    scores.behavioral * this.config.weights.behavioral +
                    scores.emotional * this.config.weights.emotional +
                    scores.contextual * this.config.weights.contextual
                );
                
                // Update metrics
                this.metrics.traitsMatch = scores.traits;
                this.metrics.paraverbalMatch = scores.paraverbal;
                this.metrics.behavioralMatch = scores.behavioral;
                this.metrics.emotionalMatch = scores.emotional;
                this.metrics.contextualMatch = scores.contextual;
                this.metrics.overall = overall;
                this.metrics.lastCalculated = Date.now();
                
                // Add to history
                this.metrics.history.push({
                    timestamp: Date.now(),
                    scores: { ...scores },
                    overall: overall
                });
                
                console.log(`‚úÖ Concordance calculated: ${overall.toFixed(1)}%`, scores);
                
                return overall;
            },
            
            // Mesurer concordance traits Big Five
            async measureTraits() {
                if (!state.initialTraits || !state.finalTraits) {
                    return 80; // Default si pas de donn√©es
                }
                
                const traits = ['openness', 'conscientiousness', 'extraversion', 'agreeableness', 'emotionalStability'];
                let totalDistance = 0;
                
                traits.forEach(trait => {
                    const distance = Math.abs(state.finalTraits[trait] - state.initialTraits[trait]) / 10;
                    totalDistance += distance;
                });
                
                const avgDistance = totalDistance / 5;
                const similarity = Math.max(0, 100 - (avgDistance * 15));
                
                return similarity;
            },
            
            // Mesurer concordance paraverbale
            async measureParaverbal() {
                const report = Paraverbal.getReport();
                
                if (!report || report.meta.messagesAnalyzed < 5) {
                    return 75; // Default si pas assez de donn√©es
                }
                
                let score = 80; // Base
                
                // Rythme coh√©rent
                if (report.rhythm.pattern === 'thoughtful' || report.rhythm.pattern === 'balanced') {
                    score += 5;
                }
                
                // Expressivit√© appropri√©e
                if (report.expressiveness.emphasisLevel === 'moderate') {
                    score += 3;
                }
                
                // Vocabulaire riche
                if (report.depth.uniqueVocabularySize > 300) {
                    score += 5;
                } else if (report.depth.uniqueVocabularySize > 200) {
                    score += 3;
                }
                
                // Style coh√©rent
                if (report.patterns.linguisticStyle.includes('reflective')) {
                    score += 4;
                }
                
                return Math.min(100, score);
            },
            
            // Mesurer concordance comportementale
            async measureBehavioral() {
                // Bas√© sur feedbacks utilisateur si disponibles
                const feedbacks = FeedbackSystem.getAllFeedbacks();
                
                if (feedbacks.length === 0) {
                    return 78; // Default
                }
                
                // Moyenne des feedbacks
                const avgFeedback = feedbacks.reduce((sum, f) => sum + f.score, 0) / feedbacks.length;
                
                // Convertir score 1-5 en pourcentage
                const behavioral = (avgFeedback / 5) * 100;
                
                return behavioral;
            },
            
            // Mesurer concordance √©motionnelle
            async measureEmotional() {
                const report = Paraverbal.getReport();
                
                if (!report) return 75;
                
                let score = 75; // Base
                
                // Vocabulaire √©motionnel vari√©
                const vocabSize = Object.keys(report.emotional.vocabulary).length;
                if (vocabSize > 10) {
                    score += 10;
                } else if (vocabSize > 5) {
                    score += 5;
                }
                
                // Intensit√© dans range normal
                const intensity = report.emotional.averageIntensity;
                if (intensity >= 4 && intensity <= 7) {
                    score += 10;
                } else if (intensity >= 3 && intensity <= 8) {
                    score += 5;
                }
                
                return Math.min(100, score);
            },
            
            // Mesurer concordance contextuelle
            async measureContextual() {
                // Pour l'instant, bas√© sur diversit√© des r√©ponses
                const messagesCount = state.responseCount;
                
                let score = 70; // Base
                
                // Plus de messages = plus de contextes vari√©s
                if (messagesCount > 30) {
                    score += 15;
                } else if (messagesCount > 20) {
                    score += 10;
                } else if (messagesCount > 10) {
                    score += 5;
                }
                
                return Math.min(100, score);
            },
            
            // D√©terminer statut du clone
            getStatus() {
                const score = this.metrics.overall;
                
                if (score < this.config.thresholds.minimal) {
                    return {
                        level: 'insufficient',
                        label: 'Insuffisant',
                        color: '#ef4444',
                        active: false,
                        message: 'Concordance insuffisante pour activation'
                    };
                } else if (score < this.config.thresholds.optimal) {
                    return {
                        level: 'minimal',
                        label: 'Minimal Fonctionnel',
                        color: '#f59e0b',
                        active: true,
                        message: 'Clone pr√™t √† l\'emploi'
                    };
                } else if (score < this.config.thresholds.worldClass) {
                    return {
                        level: 'optimal',
                        label: 'Optimal',
                        color: '#10b981',
                        active: true,
                        message: 'Excellente concordance'
                    };
                } else {
                    return {
                        level: 'worldClass',
                        label: 'Classe Mondiale',
                        color: '#8b5cf6',
                        active: true,
                        message: 'Clone d\'excellence'
                    };
                }
            },
            
            // Diagnostic automatique
            async diagnose() {
                const current = this.metrics;
                const diagnosis = {
                    status: this.getStatus(),
                    weakPoints: [],
                    recommendations: []
                };
                
                // Identifier points faibles (< 80%)
                if (current.traitsMatch < 80) {
                    diagnosis.weakPoints.push({
                        dimension: 'Traits Big Five',
                        score: current.traitsMatch,
                        priority: 'high'
                    });
                    diagnosis.recommendations.push({
                        action: 'mini_interview_traits',
                        message: '10 questions sur tes traits de personnalit√©',
                        estimatedGain: '+8-12%'
                    });
                }
                
                if (current.paraverbalMatch < 80) {
                    diagnosis.weakPoints.push({
                        dimension: 'Paraverbal',
                        score: current.paraverbalMatch,
                        priority: 'medium'
                    });
                    diagnosis.recommendations.push({
                        action: 'mini_interview_style',
                        message: '10 questions sur ton style de communication',
                        estimatedGain: '+5-8%'
                    });
                }
                
                if (current.behavioralMatch < 75) {
                    diagnosis.weakPoints.push({
                        dimension: 'Comportemental',
                        score: current.behavioralMatch,
                        priority: 'critical'
                    });
                    diagnosis.recommendations.push({
                        action: 'feedback_collection',
                        message: 'Interactions suppl√©mentaires pour affiner les r√©ponses',
                        estimatedGain: '+10-15%'
                    });
                }
                
                if (current.emotionalMatch < 80) {
                    diagnosis.weakPoints.push({
                        dimension: '√âmotionnel',
                        score: current.emotionalMatch,
                        priority: 'medium'
                    });
                }
                
                if (current.contextualMatch < 80) {
                    diagnosis.weakPoints.push({
                        dimension: 'Contextuel',
                        score: current.contextualMatch,
                        priority: 'medium'
                    });
                    diagnosis.recommendations.push({
                        action: 'context_mapping',
                        message: 'Exploration de diff√©rents contextes d\'utilisation',
                        estimatedGain: '+5-10%'
                    });
                }
                
                return diagnosis;
            },
            
            // D√©tecter d√©rive temporelle
            async detectDrift() {
                const history = this.metrics.history;
                
                if (history.length < 5) {
                    return { alert: false, message: 'Pas assez de donn√©es' };
                }
                
                const last30Days = history.filter(h => 
                    h.timestamp > Date.now() - (30 * 24 * 60 * 60 * 1000)
                );
                
                if (last30Days.length < 2) {
                    return { alert: false, message: 'Pas assez de mesures r√©centes' };
                }
                
                const firstScore = last30Days[0].overall;
                const lastScore = last30Days[last30Days.length - 1].overall;
                const delta = lastScore - firstScore;
                
                // D√©rive > 5%
                if (Math.abs(delta) > 5) {
                    return {
                        alert: true,
                        type: delta < 0 ? 'declining' : 'improving',
                        magnitude: Math.abs(delta),
                        message: delta < 0 
                            ? `Concordance a baiss√© de ${Math.abs(delta).toFixed(1)}% ce mois`
                            : `Concordance s'est am√©lior√©e de ${delta.toFixed(1)}% ce mois`,
                        recommendation: delta < 0 ? 'recalibration_suggested' : 'continue'
                    };
                }
                
                return { alert: false, message: 'Concordance stable' };
            },
            
            // Update dashboard display
            updateDisplay() {
                const concordanceScoreEl = document.getElementById('concordanceScore');
                const concordanceBarEl = document.getElementById('concordanceBar');
                const concordanceStatusEl = document.getElementById('concordanceStatus');
                const concordanceDimensionsEl = document.getElementById('concordanceDimensions');
                
                if (!concordanceScoreEl) return;
                
                const status = this.getStatus();
                const score = this.metrics.overall;
                
                // Score global
                concordanceScoreEl.textContent = `${score.toFixed(1)}%`;
                concordanceScoreEl.style.color = status.color;
                
                // Barre de progression
                if (concordanceBarEl) {
                    concordanceBarEl.style.width = `${score}%`;
                    concordanceBarEl.style.backgroundColor = status.color;
                }
                
                // Statut
                if (concordanceStatusEl) {
                    concordanceStatusEl.textContent = status.label;
                    concordanceStatusEl.style.color = status.color;
                }
                
                // Dimensions d√©taill√©es
                if (concordanceDimensionsEl) {
                    concordanceDimensionsEl.innerHTML = `
                        <div class="concordance-dimension">
                            <span class="dimension-label">Traits Big Five</span>
                            <div class="dimension-bar-container">
                                <div class="dimension-bar" style="width: ${this.metrics.traitsMatch}%; background: ${this.getColorForScore(this.metrics.traitsMatch)}"></div>
                            </div>
                            <span class="dimension-value">${this.metrics.traitsMatch.toFixed(1)}%</span>
                        </div>
                        <div class="concordance-dimension">
                            <span class="dimension-label">Paraverbal</span>
                            <div class="dimension-bar-container">
                                <div class="dimension-bar" style="width: ${this.metrics.paraverbalMatch}%; background: ${this.getColorForScore(this.metrics.paraverbalMatch)}"></div>
                            </div>
                            <span class="dimension-value">${this.metrics.paraverbalMatch.toFixed(1)}%</span>
                        </div>
                        <div class="concordance-dimension">
                            <span class="dimension-label">Comportemental</span>
                            <div class="dimension-bar-container">
                                <div class="dimension-bar" style="width: ${this.metrics.behavioralMatch}%; background: ${this.getColorForScore(this.metrics.behavioralMatch)}"></div>
                            </div>
                            <span class="dimension-value">${this.metrics.behavioralMatch.toFixed(1)}%</span>
                        </div>
                        <div class="concordance-dimension">
                            <span class="dimension-label">√âmotionnel</span>
                            <div class="dimension-bar-container">
                                <div class="dimension-bar" style="width: ${this.metrics.emotionalMatch}%; background: ${this.getColorForScore(this.metrics.emotionalMatch)}"></div>
                            </div>
                            <span class="dimension-value">${this.metrics.emotionalMatch.toFixed(1)}%</span>
                        </div>
                        <div class="concordance-dimension">
                            <span class="dimension-label">Contextuel</span>
                            <div class="dimension-bar-container">
                                <div class="dimension-bar" style="width: ${this.metrics.contextualMatch}%; background: ${this.getColorForScore(this.metrics.contextualMatch)}"></div>
                            </div>
                            <span class="dimension-value">${this.metrics.contextualMatch.toFixed(1)}%</span>
                        </div>
                    `;
                }
            },
            
            getColorForScore(score) {
                if (score >= 85) return '#10b981';
                if (score >= 75) return '#f59e0b';
                return '#ef4444';
            }
        };

        // ============================================
        // SYST√àME DE FEEDBACK HYBRIDE
        // ============================================
        const FeedbackSystem = {
            
            mode: 'learning', // learning | monitoring
            messageCount: 0,
            weekStartDate: Date.now(),
            feedbacks: [],
            
            config: {
                week1Duration: 7 * 24 * 60 * 60 * 1000, // 7 jours
                conversationalFrequency: {
                    week1: 5,      // 1 fois / 5 messages
                    after: 20      // 1 fois / 20 messages
                }
            },
            
            // D√©cider si demander feedback
            async shouldAskFeedback(message) {
                this.messageCount++;
                
                const isWeek1 = this.isWeek1();
                const frequency = isWeek1 
                    ? this.config.conversationalFrequency.week1
                    : this.config.conversationalFrequency.after;
                
                // Demander feedback bas√© sur fr√©quence
                if (this.messageCount % frequency === 0) {
                    return {
                        should: true,
                        method: 'conversational',
                        mode: isWeek1 ? 'learning' : 'monitoring'
                    };
                }
                
                return { should: false };
            },
            
            // V√©rifier si semaine 1
            isWeek1() {
                const elapsed = Date.now() - this.weekStartDate;
                return elapsed < this.config.week1Duration;
            },
            
            // Demander feedback de mani√®re conversationnelle
            async askConversationalFeedback(targetMessageId) {
                // Attendre 3-8 secondes (naturel)
                await new Promise(resolve => setTimeout(resolve, 3000 + Math.random() * 5000));
                
                const questions = [
                    "Au fait, ma r√©ponse te ressemblait ?",
                    "C'√©tait bien mon style de r√©ponse ?",
                    "√áa sonnait comme toi ?",
                    "Tu aurais r√©pondu comme √ßa ?",
                    "Est-ce que √ßa capte bien ton approche ?",
                    "Mon ton √©tait juste sur ce coup ?"
                ];
                
                const question = questions[Math.floor(Math.random() * questions.length)];
                
                // Cr√©er message de feedback
                const feedbackMsg = document.createElement('div');
                feedbackMsg.className = 'message assistant feedback-request';
                feedbackMsg.dataset.targetMessage = targetMessageId;
                feedbackMsg.innerHTML = `
                    <div class="message-avatar">C</div>
                    <div class="message-content">
                        ${question}
                        <div class="feedback-buttons">
                            <button class="feedback-btn positive" data-score="5">üëç Oui</button>
                            <button class="feedback-btn neutral" data-score="3">ü§î Moyen</button>
                            <button class="feedback-btn negative" data-score="1">üëé Non</button>
                        </div>
                    </div>
                `;
                
                elements.messages.appendChild(feedbackMsg);
                elements.messages.scrollTop = elements.messages.scrollHeight;
                
                // Event listeners pour les boutons
                feedbackMsg.querySelectorAll('.feedback-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const score = parseInt(e.target.dataset.score);
                        this.captureFeedback(targetMessageId, score, 'conversational');
                        
                        // Remplacer les boutons par confirmation
                        const contentDiv = feedbackMsg.querySelector('.message-content');
                        contentDiv.innerHTML = score >= 4 
                            ? "Super ! Merci üôè"
                            : "Not√© ! Je vais m'am√©liorer üí™";
                        
                        // Si feedback n√©gatif, demander d√©tails apr√®s 2s
                        if (score < 4) {
                            setTimeout(() => this.askFeedbackDetails(targetMessageId, score), 2000);
                        }
                    });
                });
            },
            
            // Demander d√©tails si feedback n√©gatif
            async askFeedbackDetails(messageId, initialScore) {
                const detailsMsg = document.createElement('div');
                detailsMsg.className = 'message assistant feedback-details';
                detailsMsg.innerHTML = `
                    <div class="message-avatar">C</div>
                    <div class="message-content">
                        Qu'est-ce qui n'allait pas ?
                        <div class="feedback-details-options">
                            <button class="detail-option" data-reason="too_formal">Trop formel</button>
                            <button class="detail-option" data-reason="wrong_tone">Pas mon ton</button>
                            <button class="detail-option" data-reason="too_long">Trop long</button>
                            <button class="detail-option" data-reason="not_warm">Manque chaleur</button>
                            <button class="detail-option" data-reason="skip">Passer</button>
                        </div>
                    </div>
                `;
                
                elements.messages.appendChild(detailsMsg);
                elements.messages.scrollTop = elements.messages.scrollHeight;
                
                // Event listeners
                detailsMsg.querySelectorAll('.detail-option').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const reason = e.target.dataset.reason;
                        
                        if (reason !== 'skip') {
                            this.captureDetailedFeedback(messageId, initialScore, reason);
                        }
                        
                        // Confirmation
                        const contentDiv = detailsMsg.querySelector('.message-content');
                        contentDiv.innerHTML = reason !== 'skip' 
                            ? "Compris ! Je prends note üìù"
                            : "Pas de souci üëç";
                    });
                });
            },
            
            // Capturer feedback
            captureFeedback(messageId, score, method) {
                const feedback = {
                    messageId: messageId,
                    score: score, // 1-5
                    method: method,
                    timestamp: Date.now(),
                    week: this.isWeek1() ? 1 : 2
                };
                
                this.feedbacks.push(feedback);
                
                console.log('üìù Feedback captured:', feedback);
                
                // Recalculer concordance
                this.triggerConcordanceUpdate();
            },
            
            // Capturer feedback d√©taill√©
            captureDetailedFeedback(messageId, score, reason) {
                const detailed = {
                    messageId: messageId,
                    score: score,
                    reason: reason,
                    timestamp: Date.now()
                };
                
                // Trouver et enrichir le feedback existant
                const existingFeedback = this.feedbacks.find(f => f.messageId === messageId);
                if (existingFeedback) {
                    existingFeedback.details = detailed;
                }
                
                console.log('üìù Detailed feedback captured:', detailed);
            },
            
            // Micro-feedback passif (comportement)
            captureMicroFeedback(messageElement, userAction) {
                // Capturer signaux comportementaux
                const signals = {
                    readingTime: userAction.readingTime || 0,
                    didScroll: userAction.didScroll || false,
                    didCopy: userAction.didCopy || false,
                    nextMessageDelay: userAction.nextMessageDelay || 0
                };
                
                // Interpr√©ter
                let implicitScore = 5; // Neutre
                
                if (signals.readingTime < 5 && signals.nextMessageDelay < 10) {
                    implicitScore = 5; // Satisfait, fluide
                } else if (signals.didCopy) {
                    implicitScore = 5; // Utile
                } else if (signals.nextMessageDelay > 60) {
                    implicitScore = 2; // Possible insatisfaction
                }
                
                // Enregistrer comme feedback implicite
                this.feedbacks.push({
                    messageId: messageElement.id,
                    score: implicitScore,
                    method: 'micro_passive',
                    signals: signals,
                    timestamp: Date.now(),
                    implicit: true
                });
            },
            
            // R√©cup√©rer tous les feedbacks
            getAllFeedbacks() {
                return this.feedbacks;
            },
            
            // Trigger recalcul concordance
            async triggerConcordanceUpdate() {
                // Attendre un peu pour agr√©ger
                setTimeout(async () => {
                    const newScore = await ConcordanceSystem.calculateConcordance();
                    ConcordanceSystem.updateDisplay();
                    
                    // V√©rifier si am√©lioration d√©clench√©e
                    if (newScore < 80) {
                        this.triggerAutoImprovement(newScore);
                    }
                }, 1000);
            },
            
            // D√©clencher am√©lioration automatique
            async triggerAutoImprovement(currentScore) {
                const diagnosis = await ConcordanceSystem.diagnose();
                
                if (diagnosis.recommendations.length > 0) {
                    // Afficher notification
                    Utils.showToast(
                        `Concordance : ${currentScore.toFixed(1)}% - Am√©lioration possible`,
                        'info'
                    );
                }
            }
        };

        // ============================================
        // MODULE 13: INTELLIGENCE & M√âMOIRE
        // ============================================
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // M√âMOIRE CONVERSATIONNELLE LONG TERME
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        const LongTermMemory = {
            
            context: {
                topics: [],              // { topic, mentions, lastMentioned, sentiment }
                preferences: {},         // { category: value }
                mood: 'neutral',         // current, average, history
                temporalMarkers: [],     // { event, timestamp, context }
                relationships: {},       // { entity: relationship }
                sharedExperiences: [],   // { experience, emotional_valence, timestamp }
                conversationStyle: {},   // patterns d√©tect√©s
                personalHistory: []      // √©v√©nements marquants mentionn√©s
            },
            
            storage: {
                messages: [],            // Tous les messages avec metadata enrichie
                semanticIndex: {},       // Index pour recherche rapide
                topicClusters: []        // Clustering automatique des sujets
            },
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // EXTRACTION & STOCKAGE
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            
            // Stocker message avec analyse enrichie
            async store(message, role, metadata = {}) {
                const enrichedMessage = {
                    id: metadata.messageId || `msg-${Date.now()}`,
                    role: role,
                    content: message,
                    timestamp: Date.now(),
                    analysis: await this.analyzeMessage(message, role),
                    context: { ...this.getCurrentContext() }
                };
                
                this.storage.messages.push(enrichedMessage);
                
                // Mettre √† jour contexte
                await this.updateContext(enrichedMessage);
                
                // Indexer s√©mantiquement
                await this.indexMessage(enrichedMessage);
                
                // Clustering si n√©cessaire
                if (this.storage.messages.length % 10 === 0) {
                    await this.performClustering();
                }
                
                console.log('üß† Memory stored:', enrichedMessage.id);
            },
            
            // Analyser message
            async analyzeMessage(message, role) {
                const analysis = {
                    topics: this.extractTopics(message),
                    preferences: this.extractPreferences(message),
                    mood: this.detectMood(message),
                    temporalMarkers: this.extractTemporalMarkers(message),
                    entities: this.extractEntities(message),
                    sentiment: this.analyzeSentiment(message),
                    questionType: role === 'assistant' ? this.classifyQuestion(message) : null,
                    depth: message.split(' ').length,
                    emotionalIntensity: this.measureEmotionalIntensity(message)
                };
                
                return analysis;
            },
            
            // Extraire topics
            extractTopics(text) {
                const topics = [];
                const lowerText = text.toLowerCase();
                
                // Dictionnaire de topics cl√©s
                const topicKeywords = {
                    work: ['travail', 'job', 'carri√®re', 'bureau', 'coll√®gue', 'projet', 'entreprise', 'profession'],
                    family: ['famille', 'parent', 'enfant', 'fr√®re', 's≈ìur', 'mari', 'femme', 'conjoint'],
                    emotions: ['sentiment', '√©motion', 'ressenti', 'tristesse', 'joie', 'col√®re', 'anxi√©t√©'],
                    health: ['sant√©', 'maladie', 'm√©decin', 'bien-√™tre', 'stress', 'fatigue', '√©nergie'],
                    relationships: ['relation', 'couple', 'ami', 'amour', 'conflit', 'communication'],
                    hobbies: ['loisir', 'passion', 'sport', 'musique', 'lecture', 'voyage', 'art'],
                    values: ['valeur', 'principe', 'croyance', '√©thique', 'moral', 'important'],
                    future: ['futur', 'projet', 'objectif', 'r√™ve', 'ambition', 'plan', 'espoir'],
                    past: ['pass√©', 'enfance', 'histoire', 'souvenir', 'avant', 'autrefois']
                };
                
                // D√©tecter topics
                for (const [topic, keywords] of Object.entries(topicKeywords)) {
                    const matches = keywords.filter(kw => lowerText.includes(kw));
                    if (matches.length > 0) {
                        topics.push({
                            name: topic,
                            keywords: matches,
                            confidence: matches.length / keywords.length
                        });
                    }
                }
                
                return topics;
            },
            
            // Extraire pr√©f√©rences
            extractPreferences(text) {
                const preferences = {};
                const lowerText = text.toLowerCase();
                
                // Patterns de pr√©f√©rences
                const patterns = [
                    { regex: /j'aime (.*?)[\.,\!]/gi, category: 'likes' },
                    { regex: /je pr√©f√®re (.*?)[\.,\!]/gi, category: 'preferences' },
                    { regex: /je d√©teste (.*?)[\.,\!]/gi, category: 'dislikes' },
                    { regex: /important pour moi (.*?)[\.,\!]/gi, category: 'values' }
                ];
                
                patterns.forEach(pattern => {
                    const matches = [...text.matchAll(pattern.regex)];
                    if (matches.length > 0) {
                        preferences[pattern.category] = matches.map(m => m[1].trim());
                    }
                });
                
                return preferences;
            },
            
            // D√©tecter humeur
            detectMood(text) {
                const lowerText = text.toLowerCase();
                
                const moodIndicators = {
                    happy: ['content', 'heureux', 'joyeux', 'super', 'g√©nial', 'satisfait', 'ravi'],
                    sad: ['triste', 'malheureux', 'd√©√ßu', 'd√©prim√©', 'morose'],
                    anxious: ['anxieux', 'inquiet', 'stress√©', 'nerveux', 'tendu'],
                    calm: ['calme', 'serein', 'apais√©', 'tranquille', 'd√©tendu'],
                    angry: ['en col√®re', 'furieux', '√©nerv√©', 'agac√©', 'irrit√©'],
                    excited: ['excit√©', 'enthousiaste', 'motiv√©', 'impatient']
                };
                
                let maxScore = 0;
                let detectedMood = 'neutral';
                
                for (const [mood, indicators] of Object.entries(moodIndicators)) {
                    const score = indicators.filter(ind => lowerText.includes(ind)).length;
                    if (score > maxScore) {
                        maxScore = score;
                        detectedMood = mood;
                    }
                }
                
                return {
                    primary: detectedMood,
                    confidence: maxScore > 0 ? maxScore / 3 : 0.5,
                    timestamp: Date.now()
                };
            },
            
            // Extraire marqueurs temporels
            extractTemporalMarkers(text) {
                const markers = [];
                const lowerText = text.toLowerCase();
                
                const temporalPatterns = [
                    { pattern: /hier/gi, type: 'past', offset: -1 },
                    { pattern: /aujourd'hui/gi, type: 'present', offset: 0 },
                    { pattern: /demain/gi, type: 'future', offset: 1 },
                    { pattern: /la semaine derni√®re/gi, type: 'past', offset: -7 },
                    { pattern: /le mois dernier/gi, type: 'past', offset: -30 },
                    { pattern: /r√©cemment/gi, type: 'recent_past', offset: -7 },
                    { pattern: /bient√¥t/gi, type: 'near_future', offset: 7 },
                    { pattern: /dans le pass√©/gi, type: 'distant_past', offset: null }
                ];
                
                temporalPatterns.forEach(tp => {
                    if (tp.pattern.test(text)) {
                        markers.push({
                            type: tp.type,
                            offset: tp.offset,
                            context: text
                        });
                    }
                });
                
                return markers;
            },
            
            // Extraire entit√©s (personnes, lieux)
            extractEntities(text) {
                const entities = {
                    people: [],
                    places: [],
                    organizations: []
                };
                
                // Simple regex pour noms propres (majuscule)
                const properNouns = text.match(/\b[A-Z][a-z√†√¢√§√©√®√™√´√Ø√Æ√¥√π√ª√º√ß]+\b/g) || [];
                
                // Classification basique
                properNouns.forEach(noun => {
                    // Heuristique simple
                    if (text.toLowerCase().includes(`${noun.toLowerCase()} et moi`) ||
                        text.toLowerCase().includes(`avec ${noun.toLowerCase()}`)) {
                        entities.people.push(noun);
                    }
                });
                
                return entities;
            },
            
            // Analyser sentiment
            analyzeSentiment(text) {
                const lowerText = text.toLowerCase();
                
                const positiveWords = ['bon', 'bien', 'super', 'g√©nial', 'excellent', 'magnifique', 'parfait', 'heureux'];
                const negativeWords = ['mauvais', 'mal', 'terrible', 'horrible', 'nul', 'triste', 'difficile', 'dur'];
                
                const positiveCount = positiveWords.filter(w => lowerText.includes(w)).length;
                const negativeCount = negativeWords.filter(w => lowerText.includes(w)).length;
                
                const score = (positiveCount - negativeCount) / Math.max(positiveCount + negativeCount, 1);
                
                return {
                    score: score,  // -1 to 1
                    valence: score > 0.3 ? 'positive' : score < -0.3 ? 'negative' : 'neutral'
                };
            },
            
            // Classifier type de question (si assistant)
            classifyQuestion(text) {
                const lowerText = text.toLowerCase();
                
                if (lowerText.includes('pourquoi')) return 'why';
                if (lowerText.includes('comment')) return 'how';
                if (lowerText.includes('quand')) return 'when';
                if (lowerText.includes('o√π')) return 'where';
                if (lowerText.includes('qui')) return 'who';
                if (lowerText.includes('qu\'est-ce que') || lowerText.includes('que penses-tu')) return 'what';
                if (lowerText.includes('peux-tu') || lowerText.includes('pourrais-tu')) return 'request';
                
                return 'open';
            },
            
            // Mesurer intensit√© √©motionnelle
            measureEmotionalIntensity(text) {
                const indicators = {
                    exclamation: (text.match(/!/g) || []).length,
                    capitals: (text.match(/[A-Z]{2,}/g) || []).length,
                    intensifiers: (text.match(/tr√®s|vraiment|trop|extr√™mement|absolument/gi) || []).length,
                    repetition: (text.match(/(\w+)\1+/g) || []).length
                };
                
                const score = (
                    indicators.exclamation * 2 +
                    indicators.capitals * 3 +
                    indicators.intensifiers * 1.5 +
                    indicators.repetition * 2
                ) / 10;
                
                return Math.min(10, Math.max(0, score));
            },
            
            // Mettre √† jour contexte global
            async updateContext(enrichedMessage) {
                const analysis = enrichedMessage.analysis;
                
                // Update topics
                analysis.topics.forEach(topic => {
                    const existing = this.context.topics.find(t => t.topic === topic.name);
                    if (existing) {
                        existing.mentions++;
                        existing.lastMentioned = Date.now();
                    } else {
                        this.context.topics.push({
                            topic: topic.name,
                            mentions: 1,
                            lastMentioned: Date.now(),
                            sentiment: analysis.sentiment.valence
                        });
                    }
                });
                
                // Update preferences
                Object.entries(analysis.preferences).forEach(([category, values]) => {
                    if (!this.context.preferences[category]) {
                        this.context.preferences[category] = [];
                    }
                    this.context.preferences[category].push(...values);
                });
                
                // Update mood (moving average)
                const currentMood = analysis.mood;
                if (this.context.mood === 'neutral') {
                    this.context.mood = currentMood.primary;
                } else {
                    // Moyenne pond√©r√©e (70% ancien, 30% nouveau)
                    // Simplifi√© : garde le plus r√©cent si confiance > 0.6
                    if (currentMood.confidence > 0.6) {
                        this.context.mood = currentMood.primary;
                    }
                }
                
                // Add temporal markers
                if (analysis.temporalMarkers.length > 0) {
                    this.context.temporalMarkers.push(...analysis.temporalMarkers.map(tm => ({
                        ...tm,
                        messageId: enrichedMessage.id,
                        timestamp: Date.now()
                    })));
                }
            },
            
            // Indexer message pour recherche
            async indexMessage(enrichedMessage) {
                const analysis = enrichedMessage.analysis;
                
                // Indexer par topics
                analysis.topics.forEach(topic => {
                    if (!this.storage.semanticIndex[topic.name]) {
                        this.storage.semanticIndex[topic.name] = [];
                    }
                    this.storage.semanticIndex[topic.name].push(enrichedMessage.id);
                });
                
                // Indexer par sentiment
                const sentimentKey = `sentiment_${analysis.sentiment.valence}`;
                if (!this.storage.semanticIndex[sentimentKey]) {
                    this.storage.semanticIndex[sentimentKey] = [];
                }
                this.storage.semanticIndex[sentimentKey].push(enrichedMessage.id);
            },
            
            // Clustering des sujets
            async performClustering() {
                // Simple clustering par co-occurrence de topics
                const clusters = {};
                
                this.storage.messages.forEach(msg => {
                    const topics = msg.analysis.topics.map(t => t.name);
                    if (topics.length > 1) {
                        const key = topics.sort().join('_');
                        if (!clusters[key]) {
                            clusters[key] = {
                                topics: topics,
                                messages: [],
                                frequency: 0
                            };
                        }
                        clusters[key].messages.push(msg.id);
                        clusters[key].frequency++;
                    }
                });
                
                this.storage.topicClusters = Object.values(clusters)
                    .filter(c => c.frequency > 1)
                    .sort((a, b) => b.frequency - a.frequency);
                
                console.log('üîó Topic clusters:', this.storage.topicClusters.length);
            },
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // RAPPEL & RECHERCHE
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            
            // Rappeler contexte pertinent pour message actuel
            async recall(currentMessage) {
                const relevantMemories = [];
                
                // Analyse du message actuel
                const currentAnalysis = await this.analyzeMessage(currentMessage, 'user');
                
                // 1. Recherche par topics
                const topicMatches = await this.searchByTopics(currentAnalysis.topics);
                relevantMemories.push(...topicMatches);
                
                // 2. Recherche par sentiment similaire
                const sentimentMatches = await this.searchBySentiment(currentAnalysis.sentiment);
                relevantMemories.push(...sentimentMatches);
                
                // 3. Recherche par marqueurs temporels
                if (currentAnalysis.temporalMarkers.length > 0) {
                    const temporalMatches = await this.searchByTemporal(currentAnalysis.temporalMarkers);
                    relevantMemories.push(...temporalMatches);
                }
                
                // D√©duplication et scoring
                const uniqueMemories = this.deduplicateAndScore(relevantMemories);
                
                // Top 3 plus pertinents
                const top3 = uniqueMemories.slice(0, 3);
                
                return {
                    memories: top3,
                    shouldMention: top3.length > 0 && top3[0].score > 0.7,
                    context: this.formatContext(top3)
                };
            },
            
            // Recherche par topics
            async searchByTopics(topics) {
                const matches = [];
                
                topics.forEach(topic => {
                    const messageIds = this.storage.semanticIndex[topic.name] || [];
                    messageIds.forEach(id => {
                        const message = this.storage.messages.find(m => m.id === id);
                        if (message) {
                            matches.push({
                                message: message,
                                score: topic.confidence * 0.8,
                                reason: 'topic_match',
                                detail: topic.name
                            });
                        }
                    });
                });
                
                return matches;
            },
            
            // Recherche par sentiment
            async searchBySentiment(sentiment) {
                const matches = [];
                const sentimentKey = `sentiment_${sentiment.valence}`;
                const messageIds = this.storage.semanticIndex[sentimentKey] || [];
                
                messageIds.forEach(id => {
                    const message = this.storage.messages.find(m => m.id === id);
                    if (message) {
                        matches.push({
                            message: message,
                            score: 0.5,
                            reason: 'sentiment_match',
                            detail: sentiment.valence
                        });
                    }
                });
                
                return matches.slice(-5); // Derniers 5 avec sentiment similaire
            },
            
            // Recherche par marqueurs temporels
            async searchByTemporal(markers) {
                const matches = [];
                
                markers.forEach(marker => {
                    const relevantMessages = this.context.temporalMarkers
                        .filter(tm => tm.type === marker.type)
                        .map(tm => tm.messageId);
                    
                    relevantMessages.forEach(id => {
                        const message = this.storage.messages.find(m => m.id === id);
                        if (message) {
                            matches.push({
                                message: message,
                                score: 0.6,
                                reason: 'temporal_match',
                                detail: marker.type
                            });
                        }
                    });
                });
                
                return matches;
            },
            
            // D√©duplication et scoring
            deduplicateAndScore(memories) {
                const messageScores = {};
                
                memories.forEach(mem => {
                    const id = mem.message.id;
                    if (!messageScores[id]) {
                        messageScores[id] = {
                            message: mem.message,
                            score: 0,
                            reasons: []
                        };
                    }
                    messageScores[id].score += mem.score;
                    messageScores[id].reasons.push({ reason: mem.reason, detail: mem.detail });
                });
                
                // Bonus pour messages r√©cents
                Object.values(messageScores).forEach(ms => {
                    const age = Date.now() - ms.message.timestamp;
                    const recencyBonus = Math.max(0, 1 - (age / (24 * 60 * 60 * 1000))); // Decay sur 24h
                    ms.score += recencyBonus * 0.2;
                });
                
                // Trier par score
                return Object.values(messageScores)
                    .sort((a, b) => b.score - a.score);
            },
            
            // Formatter contexte pour enrichissement
            formatContext(memories) {
                if (memories.length === 0) return '';
                
                let context = '\n\n[Contexte de conversation pertinent]:\n';
                
                memories.forEach((mem, i) => {
                    const msg = mem.message;
                    const timeAgo = this.formatTimeAgo(Date.now() - msg.timestamp);
                    const content = msg.content.substring(0, 100) + (msg.content.length > 100 ? '...' : '');
                    
                    context += `${i + 1}. Il y a ${timeAgo}, ${msg.role === 'user' ? 'tu as dit' : 'j\'ai dit'}: "${content}"\n`;
                    if (msg.analysis.sentiment.valence !== 'neutral') {
                        context += `   (Ton ${msg.analysis.sentiment.valence})\n`;
                    }
                });
                
                return context;
            },
            
            // Formatter temps √©coul√©
            formatTimeAgo(ms) {
                const minutes = Math.floor(ms / 60000);
                const hours = Math.floor(minutes / 60);
                const days = Math.floor(hours / 24);
                
                if (days > 0) return `${days} jour${days > 1 ? 's' : ''}`;
                if (hours > 0) return `${hours} heure${hours > 1 ? 's' : ''}`;
                if (minutes > 0) return `${minutes} minute${minutes > 1 ? 's' : ''}`;
                return 'quelques secondes';
            },
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // ENRICHISSEMENT PROMPTS
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            
            // Enrichir prompt avec m√©moire
            async enrichPrompt(userMessage, basePrompt) {
                const recall = await this.recall(userMessage);
                
                if (recall.shouldMention && recall.context) {
                    // Ajouter contexte pertinent au prompt
                    const enrichedPrompt = basePrompt + recall.context;
                    
                    console.log('üß† Prompt enriched with memory');
                    return {
                        prompt: enrichedPrompt,
                        memoryUsed: true,
                        memoriesCount: recall.memories.length
                    };
                }
                
                return {
                    prompt: basePrompt,
                    memoryUsed: false,
                    memoriesCount: 0
                };
            },
            
            // Obtenir contexte actuel complet
            getCurrentContext() {
                return {
                    topics: [...this.context.topics],
                    preferences: { ...this.context.preferences },
                    mood: this.context.mood,
                    recentActivity: this.storage.messages.slice(-5).map(m => ({
                        id: m.id,
                        role: m.role,
                        topics: m.analysis.topics.map(t => t.name)
                    }))
                };
            },
            
            // Export pour JSON
            getReport() {
                return {
                    context: this.context,
                    statistics: {
                        totalMessages: this.storage.messages.length,
                        topTopics: this.context.topics
                            .sort((a, b) => b.mentions - a.mentions)
                            .slice(0, 5)
                            .map(t => ({ topic: t.topic, mentions: t.mentions })),
                        averageMood: this.context.mood,
                        topicClusters: this.storage.topicClusters.slice(0, 3),
                        conversationDepth: this.calculateConversationDepth()
                    }
                };
            },
            
            // Calculer profondeur conversation
            calculateConversationDepth() {
                if (this.storage.messages.length === 0) return 0;
                
                const avgLength = this.storage.messages.reduce((sum, m) => sum + m.analysis.depth, 0) / this.storage.messages.length;
                const topicDiversity = this.context.topics.length;
                const emotionalRange = new Set(this.storage.messages.map(m => m.analysis.sentiment.valence)).size;
                
                return {
                    averageMessageLength: avgLength.toFixed(1),
                    topicDiversity: topicDiversity,
                    emotionalRange: emotionalRange,
                    score: Math.min(10, (avgLength / 20 + topicDiversity / 5 + emotionalRange / 2))
                };
            }
        };

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // MICRO-EXPRESSIONS TEXTUELLES
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        const TextualMicroExpressions = {
            
            personalTics: {
                // Tics de langage appris automatiquement
                learned: [],
                
                // Tics par d√©faut (peuvent √™tre overrid√©s)
                default: [
                    { text: "tu vois", position: "middle", frequency: 0.15 },
                    { text: "en fait", position: "start", frequency: 0.20 },
                    { text: "du coup", position: "middle", frequency: 0.15 },
                    { text: "√©coute", position: "start", frequency: 0.10 },
                    { text: "alors l√†", position: "start", frequency: 0.08 }
                ]
            },
            
            patterns: {
                // Patterns d'h√©sitation
                hesitation: ["euh", "hum", "enfin", "je veux dire", "comment dire"],
                
                // Patterns d'emphase
                emphasis: ["vraiment", "carr√©ment", "absolument", "totalement"],
                
                // Patterns de transition
                transition: ["donc", "alors", "bon", "maintenant", "ensuite"],
                
                // Patterns conversationnels
                conversational: ["tu sais quoi", "attends", "tiens", "regarde"]
            },
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // APPRENTISSAGE AUTOMATIQUE
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            
            // Apprendre des messages utilisateur
            learn(userMessages) {
                const frequencyMap = {};
                const totalMessages = userMessages.length;
                
                // Patterns √† chercher (2-3 mots)
                const targetPatterns = [
                    /\b(tu (vois|sais)|en fait|du coup|donc l√†|√©coute|bon alors|attends|tiens)\b/gi,
                    /\b(franchement|honn√™tement|sinc√®rement|clairement)\b/gi,
                    /\b(genre|style|comme|fa√ßon)\b/gi
                ];
                
                userMessages.forEach(msg => {
                    const text = msg.content.toLowerCase();
                    
                    targetPatterns.forEach(pattern => {
                        const matches = [...text.matchAll(pattern)];
                        matches.forEach(match => {
                            const tic = match[0].trim();
                            frequencyMap[tic] = (frequencyMap[tic] || 0) + 1;
                        });
                    });
                });
                
                // Ne garder que les tics fr√©quents (> 10% des messages)
                const threshold = Math.max(3, totalMessages * 0.1);
                const learnedTics = [];
                
                Object.entries(frequencyMap).forEach(([tic, count]) => {
                    if (count >= threshold) {
                        learnedTics.push({
                            text: tic,
                            position: this.determinePosition(tic),
                            frequency: count / totalMessages,
                            confidence: Math.min(1, count / (threshold * 2))
                        });
                    }
                });
                
                // Mettre √† jour les tics appris
                this.personalTics.learned = learnedTics
                    .sort((a, b) => b.frequency - a.frequency)
                    .slice(0, 8); // Top 8
                
                console.log('üéØ Learned tics:', this.personalTics.learned.length);
                
                return this.personalTics.learned;
            },
            
            // D√©terminer position pr√©f√©r√©e du tic
            determinePosition(tic) {
                // Heuristique basique
                const startWords = ['√©coute', 'bon', 'alors', 'franchement', 'honn√™tement', 'clairement'];
                const middleWords = ['tu vois', 'tu sais', 'en fait', 'du coup', 'genre'];
                
                if (startWords.some(w => tic.includes(w))) return 'start';
                if (middleWords.some(w => tic.includes(w))) return 'middle';
                
                return 'flexible';
            },
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // INJECTION NATURELLE
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            
            // Injecter tics dans r√©ponse
            inject(response) {
                // Combine learned + default
                const allTics = [...this.personalTics.learned, ...this.personalTics.default];
                
                if (allTics.length === 0) return response;
                
                // Probabilit√© d'injection (30%)
                if (Math.random() > 0.3) return response;
                
                // Choisir un tic al√©atoire pond√©r√© par fr√©quence
                const tic = this.selectWeightedTic(allTics);
                
                if (!tic) return response;
                
                // Injecter selon position
                const injected = this.injectAtPosition(response, tic);
                
                console.log(`üí¨ Tic injected: "${tic.text}"`);
                
                return injected;
            },
            
            // S√©lectionner tic pond√©r√©
            selectWeightedTic(tics) {
                const totalWeight = tics.reduce((sum, t) => sum + (t.frequency || 0.15), 0);
                let random = Math.random() * totalWeight;
                
                for (const tic of tics) {
                    random -= (tic.frequency || 0.15);
                    if (random <= 0) return tic;
                }
                
                return tics[0]; // Fallback
            },
            
            // Injecter √† la position appropri√©e
            injectAtPosition(response, tic) {
                const sentences = response.split(/([.!?]+\s+)/);
                
                if (sentences.length < 2) {
                    // R√©ponse courte, injecter au d√©but
                    return `${this.capitalize(tic.text)}, ${response.charAt(0).toLowerCase()}${response.slice(1)}`;
                }
                
                switch (tic.position) {
                    case 'start':
                        // Au d√©but de la r√©ponse
                        return `${this.capitalize(tic.text)}, ${response.charAt(0).toLowerCase()}${response.slice(1)}`;
                    
                    case 'middle':
                        // Au milieu (apr√®s 1√®re ou 2√®me phrase)
                        const insertIndex = sentences.length > 4 ? 2 : 1;
                        let position = 0;
                        for (let i = 0; i < insertIndex * 2; i++) {
                            position += sentences[i].length;
                        }
                        return response.slice(0, position) + ` ${tic.text}, ` + response.slice(position);
                    
                    case 'flexible':
                    default:
                        // Al√©atoire d√©but ou milieu
                        return Math.random() < 0.5
                            ? this.injectAtPosition(response, { ...tic, position: 'start' })
                            : this.injectAtPosition(response, { ...tic, position: 'middle' });
                }
            },
            
            // Capitaliser premi√®re lettre
            capitalize(text) {
                return text.charAt(0).toUpperCase() + text.slice(1);
            },
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // VARIATION & NATUREL
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            
            // Ajouter variation naturelle
            addNaturalVariation(response) {
                // √âviter r√©p√©titions robotiques
                // Exemple: "Je pense que" ‚Üí "Il me semble que" / "√Ä mon avis"
                
                const variations = {
                    "je pense que": ["il me semble que", "√† mon avis", "je crois que", "je dirais que"],
                    "je crois que": ["je pense que", "il me semble que", "j'ai l'impression que"],
                    "c'est int√©ressant": ["c'est fascinant", "c'est captivant", "c'est pertinent"],
                    "par exemple": ["comme", "notamment", "ainsi", "prenons le cas de"]
                };
                
                let varied = response;
                
                Object.entries(variations).forEach(([original, alternatives]) => {
                    const regex = new RegExp(original, 'gi');
                    if (regex.test(varied) && Math.random() < 0.4) {
                        const alternative = alternatives[Math.floor(Math.random() * alternatives.length)];
                        varied = varied.replace(regex, alternative);
                    }
                });
                
                return varied;
            },
            
            // Export pour rapport
            getReport() {
                return {
                    personalTics: {
                        learned: this.personalTics.learned,
                        learnedCount: this.personalTics.learned.length,
                        defaultUsed: this.personalTics.default.length
                    },
                    patterns: this.patterns,
                    statistics: {
                        totalTicsAvailable: this.personalTics.learned.length + this.personalTics.default.length,
                        injectionRate: 0.3,
                        topTics: this.personalTics.learned.slice(0, 5)
                    }
                };
            }
        };

        // ============================================
        // MODULE 13: UPDATE DISPLAY
        // ============================================
        
        function updateIntelligenceDisplay() {
            const intelligenceSection = document.getElementById('intelligenceSection');
            if (!intelligenceSection) return;
            
            // Show section after 10 messages
            if (state.responseCount >= 10) {
                intelligenceSection.style.display = 'block';
            }
            
            // Update memory stats
            const memoryMessagesCount = document.getElementById('memoryMessagesCount');
            const memoryTopicsCount = document.getElementById('memoryTopicsCount');
            const memoryMood = document.getElementById('memoryMood');
            
            if (memoryMessagesCount) {
                memoryMessagesCount.textContent = LongTermMemory.storage.messages.length;
            }
            
            if (memoryTopicsCount) {
                memoryTopicsCount.textContent = LongTermMemory.context.topics.length;
            }
            
            if (memoryMood) {
                const mood = LongTermMemory.context.mood;
                const moodEmojis = {
                    happy: 'üòä',
                    sad: 'üòî',
                    anxious: 'üò∞',
                    calm: 'üòå',
                    angry: 'üò†',
                    excited: 'ü§©',
                    neutral: 'üòê'
                };
                memoryMood.textContent = `${moodEmojis[mood] || 'üòê'} ${mood}`;
            }
            
            // Update tics
            const ticsList = document.getElementById('ticsList');
            const ticsStatus = document.getElementById('ticsStatus');
            
            if (ticsList && TextualMicroExpressions.personalTics.learned.length > 0) {
                ticsList.innerHTML = '';
                
                TextualMicroExpressions.personalTics.learned.slice(0, 8).forEach(tic => {
                    const badge = document.createElement('div');
                    badge.className = 'tic-badge';
                    badge.innerHTML = `
                        "${tic.text}"
                        <span class="tic-freq">${(tic.frequency * 100).toFixed(0)}%</span>
                    `;
                    ticsList.appendChild(badge);
                });
                
                if (ticsStatus) {
                    ticsStatus.textContent = `${TextualMicroExpressions.personalTics.learned.length} tic${TextualMicroExpressions.personalTics.learned.length > 1 ? 's' : ''} appris`;
                }
            } else if (ticsStatus) {
                if (state.responseCount < 15) {
                    ticsStatus.textContent = 'Apprentissage en cours... (15+ messages n√©cessaires)';
                } else {
                    ticsStatus.textContent = 'Aucun tic r√©current d√©tect√©';
                }
            }
        }

        // ============================================
        // INITIALIZATION
        // ============================================
        async function init() {
            // Initialize voice recognition
            VoiceRecognition.init();

            // Initialize avatar
            Avatar.init();
            Avatar.loadSavedPhoto(); // Load saved photo if exists
            console.log('‚úÖ Avatar initialized');

            // Avatar upload
            const avatarUploadInput = document.getElementById('avatarUploadInput');
            if (avatarUploadInput) {
                avatarUploadInput.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        // Check file size (max 5MB)
                        if (file.size > 5 * 1024 * 1024) {
                            Utils.showToast('Photo trop grande ! Maximum 5MB', 'danger');
                            return;
                        }
                        Avatar.loadUserPhoto(file);
                    }
                });
            }

            // Avatar remove
            const avatarRemoveBtn = document.getElementById('avatarRemoveBtn');
            if (avatarRemoveBtn) {
                avatarRemoveBtn.addEventListener('click', () => {
                    if (confirm('√ätes-vous s√ªr de vouloir supprimer votre photo ?')) {
                        Avatar.removeUserPhoto();
                    }
                });
            }

            // Avatar export
            const avatarExportBtn = document.getElementById('avatarExportBtn');
            if (avatarExportBtn) {
                avatarExportBtn.addEventListener('click', () => {
                    Avatar.exportAvatar();
                });
            }

            // Avatar name save
            const avatarNameInput = document.getElementById('avatarNameInput');
            if (avatarNameInput) {
                // Load saved name
                const savedName = localStorage.getItem('avatar_name');
                if (savedName) {
                    avatarNameInput.value = savedName;
                }
                
                // Save on change
                avatarNameInput.addEventListener('blur', () => {
                    const name = avatarNameInput.value.trim();
                    if (name) {
                        localStorage.setItem('avatar_name', name);
                        console.log(`‚úÖ Name saved: ${name}`);
                    } else {
                        localStorage.removeItem('avatar_name');
                    }
                });
            }

            // Avatar mode toggle
            const modeGenerative = document.getElementById('modeGenerative');
            const modeHybrid = document.getElementById('modeHybrid');
            
            if (modeGenerative) {
                modeGenerative.addEventListener('click', () => {
                    Avatar.setMode('generative');
                    modeGenerative.classList.add('active');
                    modeHybrid.classList.remove('active');
                });
            }
            
            if (modeHybrid) {
                modeHybrid.addEventListener('click', () => {
                    Avatar.setMode('hybrid');
                    modeHybrid.classList.add('active');
                    modeGenerative.classList.remove('active');
                });
            }

            // Avatar sidebar toggle
            const avatarSidebar = document.getElementById('avatarSidebar');
            const avatarToggleBtn = document.getElementById('avatarToggleBtn');
            const avatarFloatToggle = document.getElementById('avatarFloatToggle');
            const mainContainer = document.querySelector('.main-container');

            avatarToggleBtn.addEventListener('click', () => {
                avatarSidebar.classList.add('hidden');
                mainContainer.classList.remove('with-avatar-sidebar');
                avatarFloatToggle.classList.add('visible');
            });

            avatarFloatToggle.addEventListener('click', () => {
                avatarSidebar.classList.remove('hidden');
                mainContainer.classList.add('with-avatar-sidebar');
                avatarFloatToggle.classList.remove('visible');
            });

            // Event listeners
            elements.startBtn.addEventListener('click', () => {
                elements.welcomeScreen.classList.add('hidden');
                setTimeout(() => Warmup.start(), 500);
            });

            elements.sendBtn.addEventListener('click', sendMessage);
            elements.inputArea.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendMessage();
                }
            });

            // Voice button
            elements.voiceBtn.addEventListener('click', () => {
                VoiceRecognition.toggle();
            });

            // Auto-resize textarea
            elements.inputArea.addEventListener('input', function() {
                this.style.height = 'auto';
                this.style.height = (this.scrollHeight) + 'px';
            });

            // Paraverbal: Start capture when user starts typing
            elements.inputArea.addEventListener('focus', () => {
                if (!Paraverbal.state.currentMessageStart) {
                    Paraverbal.startCapture();
                }
            });

            // Revelations panel
            elements.revelationsToggle.addEventListener('click', () => {
                elements.revelationsPanel.classList.toggle('open');
            });

            elements.closeRevelations.addEventListener('click', () => {
                elements.revelationsPanel.classList.remove('open');
            });

            // Theme toggle
            elements.themeToggle.addEventListener('click', () => {
                document.body.classList.toggle('dark');
            });

            // Stats toggle
            elements.statsToggle.addEventListener('click', () => {
                elements.statsPanel.classList.toggle('active');
            });

            // Pause button
            elements.pauseBtn.addEventListener('click', togglePause);

            // Export button
            elements.exportBtn.addEventListener('click', exportProfile);

            // PDF Report button
            if (elements.pdfBtn) {
                elements.pdfBtn.addEventListener('click', () => {
                    PsychologicalReport.generate();
                });
            }

            // Concordance buttons
            const improveConcordanceBtn = document.getElementById('improveConcordanceBtn');
            if (improveConcordanceBtn) {
                improveConcordanceBtn.addEventListener('click', async () => {
                    Utils.showToast('Fonction d\'am√©lioration en cours de d√©veloppement...', 'info');
                    // TODO: Implement mini-interview for improvement
                });
            }

            const diagnoseConcordanceBtn = document.getElementById('diagnoseConcordanceBtn');
            if (diagnoseConcordanceBtn) {
                diagnoseConcordanceBtn.addEventListener('click', async () => {
                    const diagnosis = await ConcordanceSystem.diagnose();
                    
                    let message = `üìä Diagnostic Concordance\n\n`;
                    message += `Statut : ${diagnosis.status.label} (${ConcordanceSystem.metrics.overall.toFixed(1)}%)\n\n`;
                    
                    if (diagnosis.weakPoints.length > 0) {
                        message += `Points faibles d√©tect√©s :\n`;
                        diagnosis.weakPoints.forEach(point => {
                            message += `‚Ä¢ ${point.dimension} : ${point.score.toFixed(1)}%\n`;
                        });
                        message += `\n`;
                    }
                    
                    if (diagnosis.recommendations.length > 0) {
                        message += `Recommandations :\n`;
                        diagnosis.recommendations.forEach((rec, i) => {
                            message += `${i + 1}. ${rec.message} (${rec.estimatedGain})\n`;
                        });
                    } else {
                        message += `Aucune am√©lioration n√©cessaire ! üéâ`;
                    }
                    
                    alert(message);
                });
            }

            // Start timer
            startTimer();
        }

        function startInterview() {
            elements.chatContainer.style.display = 'flex';
            
            // Capture initial traits
            state.initialTraits = {
                openness: Avatar.state.traits.openness,
                conscientiousness: Avatar.state.traits.conscientiousness,
                extraversion: Avatar.state.traits.extraversion,
                agreeableness: Avatar.state.traits.agreeableness,
                emotionalStability: Avatar.state.traits.emotionalStability,
                timestamp: new Date().toISOString()
            };
            console.log('Initial traits captured:', state.initialTraits);
            
            // Get user name if provided
            const userName = localStorage.getItem('avatar_name');
            const greeting = userName ? `Bonjour ${userName} !` : 'Bonjour !';
            
            // Initial message (personnalis√©)
            const initialMessage = `${greeting} Je suis ravi de cr√©er ton clone de personnalit√©. Cette interview va nous permettre de capturer ton essence unique en 45-65 minutes.\n\nJe vais te poser des questions sur diff√©rents aspects de ta personnalit√©. R√©ponds spontan√©ment et honn√™tement - il n'y a pas de bonne ou mauvaise r√©ponse.\n\nCommen√ßons : Peux-tu te pr√©senter en quelques lignes ? Qui es-tu ?`;
            
            addMessage('assistant', initialMessage);
        }

        function startTimer() {
            state.startTime = Date.now();
            state.timerInterval = setInterval(() => {
                if (!state.isPaused) {
                    state.elapsedSeconds++;
                    elements.timer.textContent = `${Utils.formatTime(state.elapsedSeconds)}`;
                    Utils.updateStats();
                }
            }, 1000);
        }

        function togglePause() {
            state.isPaused = !state.isPaused;
            elements.pauseBtn.textContent = state.isPaused ? '‚ñ∂Ô∏è' : '‚è∏Ô∏è';
            Utils.showToast(state.isPaused ? 'Interview en pause' : 'Interview reprise', 'info');
        }

        function saveProgress() {
            const profileData = {
                messages: state.messages,
                stats: {
                    elapsedSeconds: state.elapsedSeconds,
                    questionCount: state.questionCount,
                    responseCount: state.responseCount,
                    totalWords: state.totalWords
                },
                warmup: state.warmupResults,
                revelations: state.revelationsUnlocked,
                contexts: state.contexts,
                timestamp: Date.now()
            };

            SecureStorage.save('clone_profile_v8', profileData);
        }

        async function exportProfile() {
            elements.loadingOverlay.classList.add('active');

            try {
                // Capture final traits
                state.finalTraits = {
                    openness: Avatar.state.traits.openness,
                    conscientiousness: Avatar.state.traits.conscientiousness,
                    extraversion: Avatar.state.traits.extraversion,
                    agreeableness: Avatar.state.traits.agreeableness,
                    emotionalStability: Avatar.state.traits.emotionalStability,
                    timestamp: new Date().toISOString()
                };
                
                // Calculate evolution
                const traitsEvolution = state.initialTraits ? {
                    openness: (state.finalTraits.openness - state.initialTraits.openness).toFixed(1),
                    conscientiousness: (state.finalTraits.conscientiousness - state.initialTraits.conscientiousness).toFixed(1),
                    extraversion: (state.finalTraits.extraversion - state.initialTraits.extraversion).toFixed(1),
                    agreeableness: (state.finalTraits.agreeableness - state.initialTraits.agreeableness).toFixed(1),
                    emotionalStability: (state.finalTraits.emotionalStability - state.initialTraits.emotionalStability).toFixed(1),
                } : null;
                
                console.log('Final traits captured:', state.finalTraits);
                console.log('Traits evolution:', traitsEvolution);
                
                // Calculate final concordance
                const finalConcordance = await ConcordanceSystem.calculateConcordance();
                console.log('Final concordance:', finalConcordance);
                
                // Generate comprehensive profile
                const profile = {
                    metadata: {
                        version: '8.0 ULTIMATE - Institut du Couple',
                        created: new Date().toISOString(),
                        duration: state.elapsedSeconds,
                        questionCount: state.questionCount,
                        responseCount: state.responseCount,
                        totalWords: state.totalWords
                    },
                    bigFiveTraits: {
                        initial: state.initialTraits,
                        final: state.finalTraits,
                        evolution: traitsEvolution
                    },
                    warmup: state.warmupResults,
                    messages: state.messages,
                    revelations: {
                        unlockedBadges: Revelations.unlockedBadges,
                        insights: Array.from(elements.insightsContainer.children).map(el => el.textContent)
                    },
                    depthGauge: {
                        score: DepthGauge.calculate(),
                        breakdown: 'Calculated based on length, diversity, emotion, examples, introspection'
                    },
                    microExpressions: MicroExpressions.analyze(),
                    contexts: state.contexts,
                    contradictions: state.contradictions,
                    reflectionNotes: state.reflectionNotes,
                    paraverbal: Paraverbal.getReport(),
                    concordance: {
                        metrics: {
                            overall: ConcordanceSystem.metrics.overall,
                            traits: ConcordanceSystem.metrics.traitsMatch,
                            paraverbal: ConcordanceSystem.metrics.paraverbalMatch,
                            behavioral: ConcordanceSystem.metrics.behavioralMatch,
                            emotional: ConcordanceSystem.metrics.emotionalMatch,
                            contextual: ConcordanceSystem.metrics.contextualMatch
                        },
                        status: ConcordanceSystem.getStatus(),
                        history: ConcordanceSystem.metrics.history,
                        lastCalculated: ConcordanceSystem.metrics.lastCalculated
                    },
                    feedback: {
                        mode: FeedbackSystem.mode,
                        totalFeedbacks: FeedbackSystem.feedbacks.length,
                        averageScore: FeedbackSystem.feedbacks.length > 0
                            ? FeedbackSystem.feedbacks.reduce((sum, f) => sum + f.score, 0) / FeedbackSystem.feedbacks.length
                            : null,
                        feedbacks: FeedbackSystem.feedbacks
                    },
                    longTermMemory: {
                        context: LongTermMemory.context,
                        statistics: {
                            totalMessages: LongTermMemory.storage.messages.length,
                            topTopics: LongTermMemory.context.topics
                                .sort((a, b) => b.mentions - a.mentions)
                                .slice(0, 5)
                                .map(t => ({ topic: t.topic, mentions: t.mentions })),
                            currentMood: LongTermMemory.context.mood,
                            topicClusters: LongTermMemory.storage.topicClusters.slice(0, 3),
                            conversationDepth: LongTermMemory.calculateConversationDepth()
                        },
                        report: LongTermMemory.getReport()
                    },
                    textualMicroExpressions: {
                        personalTics: {
                            learned: TextualMicroExpressions.personalTics.learned,
                            default: TextualMicroExpressions.personalTics.default
                        },
                        statistics: {
                            totalTicsAvailable: TextualMicroExpressions.personalTics.learned.length + 
                                               TextualMicroExpressions.personalTics.default.length,
                            learnedCount: TextualMicroExpressions.personalTics.learned.length,
                            injectionRate: 0.3,
                            topLearned: TextualMicroExpressions.personalTics.learned.slice(0, 5)
                        },
                        report: TextualMicroExpressions.getReport()
                    }
                };

                // Export JSON
                const jsonBlob = new Blob([JSON.stringify(profile, null, 2)], { type: 'application/json' });
                const jsonUrl = URL.createObjectURL(jsonBlob);
                const jsonA = document.createElement('a');
                jsonA.href = jsonUrl;
                jsonA.download = `clone-personality-v8-${Date.now()}.json`;
                jsonA.click();

                Utils.showToast('Profil export√© avec succ√®s !', 'success', 'Fichier JSON t√©l√©charg√©');
                
                // Show traits evolution
                if (traitsEvolution) {
                    const totalEvolution = Object.values(traitsEvolution)
                        .reduce((sum, val) => sum + Math.abs(parseFloat(val)), 0);
                    
                    if (totalEvolution > 0.5) {
                        setTimeout(() => {
                            const evolutionMsg = `√âvolution des traits pendant l'interview : ${totalEvolution.toFixed(1)} points au total`;
                            Utils.showToast(evolutionMsg, 'info');
                        }, 2000);
                    }
                }
            } catch (error) {
                console.error('Export error:', error);
                Utils.showToast('Erreur lors de l\'export', 'danger');
            } finally {
                elements.loadingOverlay.classList.remove('active');
            }
        }

        // ============================================
        // START APPLICATION
        // ============================================
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>        // ====================
